// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6 (swiftlang-5.6.0.323.62 clang-1316.0.20.8)
// swift-module-flags: -target arm64-apple-ios9.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name LinkaAPIKit
import CoreBluetooth
import CoreFoundation
import CoreLocation
import Darwin
import Dispatch
import Foundation
@_exported import LinkaAPIKit
import MobileCoreServices
import ObjectiveC
import Security
import Swift
import SystemConfiguration
import UIKit
import _Concurrency
public func <- <T>(left: inout T, right: LinkaAPIKit.Map) where T : Swift.SignedInteger
public func <- <T>(left: inout T?, right: LinkaAPIKit.Map) where T : Swift.SignedInteger
public func <- <T>(left: inout T, right: LinkaAPIKit.Map) where T : Swift.UnsignedInteger
public func <- <T>(left: inout T?, right: LinkaAPIKit.Map) where T : Swift.UnsignedInteger
public protocol Authenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
@_inheritsConvenienceInitializers final public class CBCMAC : LinkaAPIKit.CMAC {
  override final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  override public init(key: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
final public class Checksum {
  @usableFromInline
  internal static let table32: [Swift.UInt32]
  @usableFromInline
  internal static let table32c: [Swift.UInt32]
  @usableFromInline
  internal static let table16: [Swift.UInt16]
  @usableFromInline
  internal init()
  @inlinable final internal func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32c[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    var crc: UInt16 = seed != nil ? seed! : 0x0000
    for chunk in message.batched(by: 256) {
      for b in chunk {
        crc = (crc >> 8) ^ Checksum.table16[Int((crc ^ UInt16(b)) & 0xFF)]
      }
    }
    return crc
  }
  @objc deinit
}
extension LinkaAPIKit.Checksum {
  @inlinable public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32c(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    Checksum().crc16(message, seed: seed)
  }
}
public struct OFB : LinkaAPIKit.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: LinkaAPIKit.OFB.Error, b: LinkaAPIKit.OFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: LinkaAPIKit.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping LinkaAPIKit.CipherOperationOnBlock, encryptionOperation: @escaping LinkaAPIKit.CipherOperationOnBlock) throws -> LinkaAPIKit.CipherModeWorker
}
final public class GCM : LinkaAPIKit.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: LinkaAPIKit.GCM.Mode, b: LinkaAPIKit.GCM.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: LinkaAPIKit.BlockModeOption
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: LinkaAPIKit.GCM.Error, b: LinkaAPIKit.GCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: LinkaAPIKit.GCM.Mode = .detached)
  convenience public init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: LinkaAPIKit.GCM.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping LinkaAPIKit.CipherOperationOnBlock, encryptionOperation: @escaping LinkaAPIKit.CipherOperationOnBlock) throws -> LinkaAPIKit.CipherModeWorker
  @objc deinit
}
public struct HKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: LinkaAPIKit.HKDF.Error, b: LinkaAPIKit.HKDF.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: LinkaAPIKit.HMAC.Variant = .sha256) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
}
open class TransformOf<ObjectType, JSONType> : LinkaAPIKit.TransformType {
  public typealias Object = ObjectType
  public typealias JSON = JSONType
  public init(fromJSON: @escaping (JSONType?) -> ObjectType?, toJSON: @escaping (ObjectType?) -> JSONType?)
  open func transformFromJSON(_ value: Any?) -> ObjectType?
  open func transformToJSON(_ value: ObjectType?) -> JSONType?
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Request {
  @objc deinit
}
extension LinkaAPIKit.Request : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension LinkaAPIKit.Request : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
open class DateTransform : LinkaAPIKit.TransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.Double
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.Double?
  @objc deinit
}
public enum PairingUpState : Swift.Int {
  case idle
  case connect
  case discover_SERVICES
  case discover_CHARACTERISTICS
  case disconnect
  case done
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers open class StateTransitionReason : ObjectiveC.NSObject {
  public static let REASON_NONE: LinkaAPIKit.Byte
  public static let REASON_KEYPRESS: LinkaAPIKit.Byte
  public static let REASON_TIMEOUT: LinkaAPIKit.Byte
  public static let REASON_LIMIT_SW: LinkaAPIKit.Byte
  public static let REASON_AUTH_REQ: LinkaAPIKit.Byte
  public static let REASON_PAC_ENTRY: LinkaAPIKit.Byte
  public static let REASON_PAC_FAIL: LinkaAPIKit.Byte
  public static let REASON_STARTUP_UNKNOWN: LinkaAPIKit.Byte
  public static let REASON_TEST_MODE: LinkaAPIKit.Byte
  public static let REASON_HW_ERR: LinkaAPIKit.Byte
  public static let REASON_TIMEOUT_EXIT_LOCKED_LIM: LinkaAPIKit.Byte
  public static let REASON_TIMEOUT_EXIT_UNLOCKED_LIM: LinkaAPIKit.Byte
  public static let REASON_FAULT: LinkaAPIKit.Byte
  public static let REASON_STALL: LinkaAPIKit.Byte
  public static let REASON_BLE_CMD: LinkaAPIKit.Byte
  public static let REASON_IDLE_TIMEOUT: LinkaAPIKit.Byte
  public static let REASON_STARTUP_BUTTONPRESS: LinkaAPIKit.Byte
  public static let REASON_STARTUP_ACCEL1: LinkaAPIKit.Byte
  public static let REASON_STARTUP_ACCEL2: LinkaAPIKit.Byte
  public static let REASON_STARTUP_USB: LinkaAPIKit.Byte
  open class func getTransitionReason(_ reason: LinkaAPIKit.Byte) -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
public typealias Long = Swift.UInt32
public typealias Byte = Swift.UInt8
@objc public class LockAdV1 : ObjectiveC.NSObject {
  public static let ACCEL_RESOLUTION_G_16BIT: (Swift.Double)
  public static let ACCEL_RESOLUTION_G_8BIT: Swift.Double
  public static let TEMP_RESOLUTION_C: Swift.Double
  public static let VLS_FLAG_ALARM_TIP: (Swift.UInt)
  public static let VLT_TEST_EEPROM: (Swift.UInt)
  public static let VLT_TEST_ACCEL: (Swift.UInt)
  public static let VLT_TEST_MOTOR_DRIVER: (Swift.UInt)
  public static let VLT_TEST_I2CBUSS: (Swift.UInt)
  public static let VLT_TEST_RADIO: (Swift.UInt)
  public static let VLT_TEST_ENCRYP: (Swift.UInt)
  public static let VLT_TEST_CRC: (Swift.UInt)
  public static let VLT_TEST_BOOTLOADER_PRESENT: (Swift.UInt)
  public static let VLT_TEST_SETTINGS: (Swift.UInt)
  public func GetStatusFlags() -> LinkaAPIKit.Long
  public func GetLockState() -> LinkaAPIKit.LockState
  public func GetAuthState() -> LinkaAPIKit.AuthState
  public func GetBatteryVoltage() -> Swift.Double
  public func GetAccelX() -> Swift.Int
  public func GetAccelY() -> Swift.Int
  public func GetAccelZ() -> Swift.Int
  public func GetAccelX_g() -> Swift.Double
  public func GetAccelY_g() -> Swift.Double
  public func GetAccelZ_g() -> Swift.Double
  public func GetMACAddr_str() -> Swift.String
  public init(data: [LinkaAPIKit.Byte], offset: Swift.Int)
  @objc deinit
}
public protocol MapContext {
}
final public class Map {
  final public let mappingType: LinkaAPIKit.MappingType
  final public var JSON: [Swift.String : Any] {
    get
  }
  final public var isKeyPresent: Swift.Bool {
    get
  }
  final public var currentValue: Any? {
    get
  }
  final public var currentKey: Swift.String? {
    get
  }
  final public var nestedKeyDelimiter: Swift.String {
    get
  }
  final public var context: LinkaAPIKit.MapContext?
  final public var shouldIncludeNilValues: Swift.Bool
  final public let toObject: Swift.Bool
  public init(mappingType: LinkaAPIKit.MappingType, JSON: [Swift.String : Any], toObject: Swift.Bool = false, context: LinkaAPIKit.MapContext? = nil, shouldIncludeNilValues: Swift.Bool = false)
  final public subscript(key: Swift.String) -> LinkaAPIKit.Map {
    get
  }
  final public subscript(key: Swift.String, delimiter delimiter: Swift.String) -> LinkaAPIKit.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool) -> LinkaAPIKit.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool, delimiter delimiter: Swift.String) -> LinkaAPIKit.Map {
    get
  }
  final public subscript(key: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> LinkaAPIKit.Map {
    get
  }
  final public subscript(key: Swift.String, delimiter delimiter: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> LinkaAPIKit.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool, ignoreNil ignoreNil: Swift.Bool) -> LinkaAPIKit.Map {
    get
  }
  final public subscript(key: Swift.String, nested nested: Swift.Bool?, delimiter delimiter: Swift.String, ignoreNil ignoreNil: Swift.Bool) -> LinkaAPIKit.Map {
    get
  }
  final public func value<T>() -> T?
  @objc deinit
}
public struct CCM {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: LinkaAPIKit.CCM.Error, b: LinkaAPIKit.CCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: LinkaAPIKit.BlockModeOption
  public let customBlockSize: Swift.Int?
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping LinkaAPIKit.CipherOperationOnBlock, encryptionOperation: @escaping LinkaAPIKit.CipherOperationOnBlock) throws -> LinkaAPIKit.CipherModeWorker
}
@usableFromInline
final internal class StreamEncryptor : LinkaAPIKit.Cryptor, LinkaAPIKit.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: LinkaAPIKit.CipherModeWorker
  @usableFromInline
  final internal let padding: LinkaAPIKit.Padding
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: LinkaAPIKit.Padding, _ worker: LinkaAPIKit.CipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    var accumulated = Array(bytes)
    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      accumulated = self.padding.add(to: accumulated, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    var encrypted = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in accumulated.batched(by: self.blockSize) {
      encrypted += self.worker.encrypt(block: chunk)
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = encrypted.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if var finalizingWorker = worker as? FinalizingEncryptModeWorker, isLast == true {
      encrypted = Array(try finalizingWorker.finalize(encrypt: encrypted.slice))
    }

    return encrypted
  }
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
extension LinkaAPIKit.PKCS5 {
  public struct PBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: LinkaAPIKit.PKCS5.PBKDF1.Error, b: LinkaAPIKit.PKCS5.PBKDF1.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Variant {
      case md5, sha1
      @usableFromInline
      internal var size: Swift.Int {
        get
      }
      @usableFromInline
      internal func calculateHash(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
      public static func == (a: LinkaAPIKit.PKCS5.PBKDF1.Variant, b: LinkaAPIKit.PKCS5.PBKDF1.Variant) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @usableFromInline
    internal let iterations: Swift.Int
    @usableFromInline
    internal let variant: LinkaAPIKit.PKCS5.PBKDF1.Variant
    @usableFromInline
    internal let keyLength: Swift.Int
    @usableFromInline
    internal let t1: Swift.Array<Swift.UInt8>
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: LinkaAPIKit.PKCS5.PBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    @inlinable public func calculate() -> Swift.Array<Swift.UInt8> {
      var t = self.t1
      for _ in 2...self.iterations {
        t = self.variant.calculateHash(t)
      }
      return Array(t[0..<self.keyLength])
    }
  }
}
extension Foundation.Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: LinkaAPIKit.SHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: LinkaAPIKit.Cipher) throws -> Foundation.Data
  public func decrypt(cipher: LinkaAPIKit.Cipher) throws -> Foundation.Data
  public func authenticate(with authenticator: LinkaAPIKit.Authenticator) throws -> Foundation.Data
}
extension Foundation.Data {
  public init(hex: Swift.String)
  public var bytes: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
open class DateFormatterTransform : LinkaAPIKit.TransformType {
  public typealias Object = Foundation.Date
  public typealias JSON = Swift.String
  final public let dateFormatter: Foundation.DateFormatter
  public init(dateFormatter: Foundation.DateFormatter)
  open func transformFromJSON(_ value: Any?) -> Foundation.Date?
  open func transformToJSON(_ value: Foundation.Date?) -> Swift.String?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class KeychainService : ObjectiveC.NSObject {
  public class func saveUUID(token: Foundation.NSString)
  public class func loadUUID() -> Foundation.NSString?
  public class func saveLockKey(mac_id: Foundation.NSString, key: Foundation.NSString)
  public class func loadLockKey(mac_id: Foundation.NSString) -> Foundation.NSString?
  @objc override dynamic public init()
  @objc deinit
}
final public class HMAC : LinkaAPIKit.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: LinkaAPIKit.HMAC.Error, b: LinkaAPIKit.HMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant {
    case sha1, sha256, sha384, sha512, md5
    public static func == (a: LinkaAPIKit.HMAC.Variant, b: LinkaAPIKit.HMAC.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: LinkaAPIKit.HMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public protocol Cryptors : AnyObject {
  func makeEncryptor() throws -> LinkaAPIKit.Cryptor & LinkaAPIKit.Updatable
  func makeDecryptor() throws -> LinkaAPIKit.Cryptor & LinkaAPIKit.Updatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension LinkaAPIKit.Cryptors {
  public static func randomIV(_ count: Swift.Int) -> Swift.Array<Swift.UInt8>
}
final public class AES {
  public enum Error : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: LinkaAPIKit.AES.Error, b: LinkaAPIKit.AES.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @usableFromInline
  final internal let variantNr: Swift.Int
  @usableFromInline
  final internal let variantNb: Swift.Int
  @usableFromInline
  final internal let variantNk: Swift.Int
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: LinkaAPIKit.AES.Variant
  @usableFromInline
  final internal let blockMode: LinkaAPIKit.BlockMode
  @usableFromInline
  final internal let padding: LinkaAPIKit.Padding
  @usableFromInline
  final internal var expandedKey: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  final internal var expandedKeyInv: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  internal static let T0: [Swift.UInt32]
  @usableFromInline
  internal static let T0_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T1: [Swift.UInt32]
  @usableFromInline
  internal static let T1_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T2: [Swift.UInt32]
  @usableFromInline
  internal static let T2_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T3: [Swift.UInt32]
  @usableFromInline
  internal static let T3_INV: [Swift.UInt32]
  @usableFromInline
  internal static let U1: [Swift.UInt32]
  @usableFromInline
  internal static let U2: [Swift.UInt32]
  @usableFromInline
  internal static let U3: [Swift.UInt32]
  @usableFromInline
  internal static let U4: [Swift.UInt32]
  public init(key: Swift.Array<Swift.UInt8>, blockMode: LinkaAPIKit.BlockMode, padding: LinkaAPIKit.Padding = .pkcs7) throws
  @inlinable final internal func encrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>? {
    if self.blockMode.options.contains(.paddingRequired) && block.count != AES.blockSize {
      return Array(block)
    }

    let rounds = self.variantNr
    let rk = self.expandedKey

    let b00 = UInt32(block[block.startIndex.advanced(by: 0)])
    let b01 = UInt32(block[block.startIndex.advanced(by: 1)]) << 8
    let b02 = UInt32(block[block.startIndex.advanced(by: 2)]) << 16
    let b03 = UInt32(block[block.startIndex.advanced(by: 3)]) << 24
    var b0 = b00 | b01 | b02 | b03

    let b10 = UInt32(block[block.startIndex.advanced(by: 4)])
    let b11 = UInt32(block[block.startIndex.advanced(by: 5)]) << 8
    let b12 = UInt32(block[block.startIndex.advanced(by: 6)]) << 16
    let b13 = UInt32(block[block.startIndex.advanced(by: 7)]) << 24
    var b1 = b10 | b11 | b12 | b13

    let b20 = UInt32(block[block.startIndex.advanced(by: 8)])
    let b21 = UInt32(block[block.startIndex.advanced(by: 9)]) << 8
    let b22 = UInt32(block[block.startIndex.advanced(by: 10)]) << 16
    let b23 = UInt32(block[block.startIndex.advanced(by: 11)]) << 24
    var b2 = b20 | b21 | b22 | b23

    let b30 = UInt32(block[block.startIndex.advanced(by: 12)])
    let b31 = UInt32(block[block.startIndex.advanced(by: 13)]) << 8
    let b32 = UInt32(block[block.startIndex.advanced(by: 14)]) << 16
    let b33 = UInt32(block[block.startIndex.advanced(by: 15)]) << 24
    var b3 = b30 | b31 | b32 | b33

    let tLength = 4
    let t = UnsafeMutablePointer<UInt32>.allocate(capacity: tLength)
    t.initialize(repeating: 0, count: tLength)
    defer {
      t.deinitialize(count: tLength)
      t.deallocate()
    }

    for r in 0..<rounds - 1 {
      t[0] = b0 ^ rk[r][0]
      t[1] = b1 ^ rk[r][1]
      t[2] = b2 ^ rk[r][2]
      t[3] = b3 ^ rk[r][3]

      let lb00 = AES.T0[Int(t[0] & 0xff)]
      let lb01 = AES.T1[Int((t[1] >> 8) & 0xff)]
      let lb02 = AES.T2[Int((t[2] >> 16) & 0xff)]
      let lb03 = AES.T3[Int(t[3] >> 24)]
      b0 = lb00 ^ lb01 ^ lb02 ^ lb03

      let lb10 = AES.T0[Int(t[1] & 0xff)]
      let lb11 = AES.T1[Int((t[2] >> 8) & 0xff)]
      let lb12 = AES.T2[Int((t[3] >> 16) & 0xff)]
      let lb13 = AES.T3[Int(t[0] >> 24)]
      b1 = lb10 ^ lb11 ^ lb12 ^ lb13

      let lb20 = AES.T0[Int(t[2] & 0xff)]
      let lb21 = AES.T1[Int((t[3] >> 8) & 0xff)]
      let lb22 = AES.T2[Int((t[0] >> 16) & 0xff)]
      let lb23 = AES.T3[Int(t[1] >> 24)]
      b2 = lb20 ^ lb21 ^ lb22 ^ lb23

      let lb30 = AES.T0[Int(t[3] & 0xff)]
      let lb31 = AES.T1[Int((t[0] >> 8) & 0xff)]
      let lb32 = AES.T2[Int((t[1] >> 16) & 0xff)]
      let lb33 = AES.T3[Int(t[2] >> 24)]
      b3 = lb30 ^ lb31 ^ lb32 ^ lb33
    }

    // last round
    let r = rounds - 1

    t[0] = b0 ^ rk[r][0]
    t[1] = b1 ^ rk[r][1]
    t[2] = b2 ^ rk[r][2]
    t[3] = b3 ^ rk[r][3]

    // rounds
    b0 = F1(t[0], t[1], t[2], t[3]) ^ rk[rounds][0]
    b1 = F1(t[1], t[2], t[3], t[0]) ^ rk[rounds][1]
    b2 = F1(t[2], t[3], t[0], t[1]) ^ rk[rounds][2]
    b3 = F1(t[3], t[0], t[1], t[2]) ^ rk[rounds][3]

    let encrypted: Array<UInt8> = [
      UInt8(b0 & 0xff), UInt8((b0 >> 8) & 0xff), UInt8((b0 >> 16) & 0xff), UInt8((b0 >> 24) & 0xff),
      UInt8(b1 & 0xff), UInt8((b1 >> 8) & 0xff), UInt8((b1 >> 16) & 0xff), UInt8((b1 >> 24) & 0xff),
      UInt8(b2 & 0xff), UInt8((b2 >> 8) & 0xff), UInt8((b2 >> 16) & 0xff), UInt8((b2 >> 24) & 0xff),
      UInt8(b3 & 0xff), UInt8((b3 >> 8) & 0xff), UInt8((b3 >> 16) & 0xff), UInt8((b3 >> 24) & 0xff)
    ]
    return encrypted
  }
  @usableFromInline
  final internal func decrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
  @objc deinit
}
extension LinkaAPIKit.AES {
  @usableFromInline
  @inline(__always) final internal func F1(_ x0: Swift.UInt32, _ x1: Swift.UInt32, _ x2: Swift.UInt32, _ x3: Swift.UInt32) -> Swift.UInt32
}
extension LinkaAPIKit.AES : LinkaAPIKit.Cipher {
  @inlinable final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    let blockSize = self.blockMode.customBlockSize ?? AES.blockSize
    let chunks = bytes.batched(by: blockSize)

    var oneTimeCryptor = try makeEncryptor()
    var out = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in chunks {
      out += try oneTimeCryptor.update(withBytes: chunk, isLast: false)
    }
    // Padding may be added at the very end
    out += try oneTimeCryptor.finish()

    if self.blockMode.options.contains(.paddingRequired) && (out.count % AES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    return out
  }
  @inlinable final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    if self.blockMode.options.contains(.paddingRequired) && (bytes.count % AES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    var oneTimeCryptor = try makeDecryptor()
    let chunks = bytes.batched(by: AES.blockSize)
    if chunks.isEmpty {
      throw Error.invalidData
    }

    var out = Array<UInt8>(reserveCapacity: bytes.count)

    var lastIdx = chunks.startIndex
    chunks.indices.formIndex(&lastIdx, offsetBy: chunks.count - 1)

    // To properly remove padding, `isLast` has to be known when called with the last chunk of ciphertext
    // Last chunk of ciphertext may contains padded data so next call to update(..) won't be able to remove it
    for idx in chunks.indices {
      out += try oneTimeCryptor.update(withBytes: chunks[idx], isLast: idx == lastIdx)
    }
    return out
  }
}
public struct CTR {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: LinkaAPIKit.CTR.Error, b: LinkaAPIKit.CTR.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: LinkaAPIKit.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping LinkaAPIKit.CipherOperationOnBlock, encryptionOperation: @escaping LinkaAPIKit.CipherOperationOnBlock) throws -> LinkaAPIKit.CipherModeWorker
}
public typealias Callback = ((_ peripheral: CoreBluetooth.CBPeripheral, _ error: Foundation.NSError?) -> Swift.Void)
public typealias CallbackRSSI = ((_ peripheral: CoreBluetooth.CBPeripheral, _ RSSI: Foundation.NSNumber?) -> Swift.Void)
@objc @_inheritsConvenienceInitializers @objcMembers public class LinkaBLEConnectManager : ObjectiveC.NSObject, LinkaAPIKit.LinkaBLECentralManagerDelegate {
  @objc public var peripheral: CoreBluetooth.CBPeripheral!
  @objc public var manager: LinkaAPIKit.LinkaBLECentralManager!
  public var state: LinkaAPIKit.PairingUpState
  @objc public var callback_API: LinkaAPIKit.Callback!
  @objc public var callbackOnLostConnection_API: LinkaAPIKit.Callback!
  @objc public var callbackOnReadRSSI_API: LinkaAPIKit.CallbackRSSI!
  @objc public var callbackOnLostConnection: LinkaAPIKit.Callback!
  @objc public var callbackOnReadRSSI: LinkaAPIKit.CallbackRSSI!
  @objc public var callback: LinkaAPIKit.Callback!
  @objc public func startConnect(peripheral: CoreBluetooth.CBPeripheral, callback: LinkaAPIKit.Callback!, callbackOnLostConnection: LinkaAPIKit.Callback!, callbackOnReadRSSI: LinkaAPIKit.CallbackRSSI!)
  @objc public func startDisconnect(peripheral: CoreBluetooth.CBPeripheral, callback: @escaping (_ peripheral: CoreBluetooth.CBPeripheral, _ error: Foundation.NSError?) -> Swift.Void)
  @objc public func stopCommunication()
  @objc public func kill()
  @objc public func startRoutine()
  @objc public func nextRoutine()
  public func nextRoutine(state: LinkaAPIKit.PairingUpState!)
  @objc public func connect() -> Swift.Bool
  @objc public func discoverServices() -> Swift.Bool
  @objc public func discoverCharacteristics() -> Swift.Bool
  @objc public func readRSSI() -> Swift.Bool
  @objc public func disconnect() -> Swift.Bool
  @objc public func done()
  @objc public func linka_delegate_instance() -> Swift.AnyObject
  @objc public func onBLEPoweredOn()
  @objc public func onBLEPoweredOff()
  @objc public func onConnectToPeripheral(peripheral: CoreBluetooth.CBPeripheral)
  @objc public func onDisconnectToPeripheral(peripheral: CoreBluetooth.CBPeripheral, error: Foundation.NSError?)
  @objc public func onFailToConnectPeripheral(peripheral: CoreBluetooth.CBPeripheral, error: Foundation.NSError?)
  @objc public func onRefreshPeripheralObject(peripheral: CoreBluetooth.CBPeripheral, RSSI: Foundation.NSNumber!, error: Foundation.NSError?)
  @objc public func onRefreshPeripheralServices(peripheral: CoreBluetooth.CBPeripheral)
  @objc public func onCreateNotificationForPeripheralCharacteristic(peripheral: CoreBluetooth.CBPeripheral, characteristic: CoreBluetooth.CBCharacteristic, isConnected: Swift.Bool)
  @objc public func onRefreshPeripheralCharacteristic(peripheral: CoreBluetooth.CBPeripheral, characteristic: CoreBluetooth.CBCharacteristic)
  @objc override dynamic public init()
  @objc deinit
}
extension Swift.String {
  public func decryptBase64ToString(cipher: LinkaAPIKit.Cipher) throws -> Swift.String
  public func decryptBase64(cipher: LinkaAPIKit.Cipher) throws -> Swift.Array<Swift.UInt8>
}
public typealias CipherOperationOnBlock = (_ block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol BlockMode {
  var options: LinkaAPIKit.BlockModeOption { get }
  @inlinable func worker(blockSize: Swift.Int, cipherOperation: @escaping LinkaAPIKit.CipherOperationOnBlock, encryptionOperation: @escaping LinkaAPIKit.CipherOperationOnBlock) throws -> LinkaAPIKit.CipherModeWorker
  var customBlockSize: Swift.Int? { get }
}
extension LinkaAPIKit.PKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: LinkaAPIKit.PKCS5.PBKDF2.Error, b: LinkaAPIKit.PKCS5.PBKDF2.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: LinkaAPIKit.HMAC.Variant = .sha256) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
  }
}
extension LinkaAPIKit.AES : LinkaAPIKit.Cryptors {
  @inlinable final public func makeEncryptor() throws -> LinkaAPIKit.Cryptor & LinkaAPIKit.Updatable {
    let blockSize = blockMode.customBlockSize ?? AES.blockSize
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: encrypt, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try StreamEncryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try BlockEncryptor(blockSize: blockSize, padding: padding, worker)
  }
  @inlinable final public func makeDecryptor() throws -> LinkaAPIKit.Cryptor & LinkaAPIKit.Updatable {
    let blockSize = blockMode.customBlockSize ?? AES.blockSize
    let cipherOperation: CipherOperationOnBlock = blockMode.options.contains(.useEncryptToDecrypt) == true ? encrypt : decrypt
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: cipherOperation, encryptionOperation: encrypt)
    if worker is StreamModeWorker {
      return try StreamDecryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try BlockDecryptor(blockSize: blockSize, padding: padding, worker)
  }
}
public class BlockDecryptor : LinkaAPIKit.Cryptor, LinkaAPIKit.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let padding: LinkaAPIKit.Padding
  @usableFromInline
  internal var worker: LinkaAPIKit.CipherModeWorker
  @usableFromInline
  internal var accumulated: [Swift.UInt8]
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: LinkaAPIKit.Padding, _ worker: LinkaAPIKit.CipherModeWorker) throws
  @inlinable public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    // If a worker (eg GCM) can combine ciphertext + tag
    // we need to remove tag from the ciphertext.
    if !isLast && self.accumulated.count < self.blockSize + self.worker.additionalBufferSize {
      return []
    }

    let accumulatedWithoutSuffix: Array<UInt8>
    if self.worker.additionalBufferSize > 0 {
      // FIXME: how slow is that?
      accumulatedWithoutSuffix = Array(self.accumulated.prefix(self.accumulated.count - self.worker.additionalBufferSize))
    } else {
      accumulatedWithoutSuffix = self.accumulated
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: accumulatedWithoutSuffix.count)
    // Processing in a block-size manner. It's good for block modes, but bad for stream modes.
    for var chunk in accumulatedWithoutSuffix.batched(by: self.blockSize) {
      if isLast || (accumulatedWithoutSuffix.count - processedBytesCount) >= blockSize {
        let isLastChunk = processedBytesCount + chunk.count == accumulatedWithoutSuffix.count

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          chunk = try finalizingWorker.willDecryptLast(bytes: chunk + accumulated.suffix(worker.additionalBufferSize)) // tag size
        }

        if !chunk.isEmpty {
          plaintext += worker.decrypt(block: chunk)
        }

        if isLast, isLastChunk, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
          plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
        }

        processedBytesCount += chunk.count
      }
    }
    accumulated.removeFirst(processedBytesCount) // super-slow

    if isLast {
      if accumulatedWithoutSuffix.isEmpty, var finalizingWorker = worker as? FinalizingDecryptModeWorker {
        try finalizingWorker.willDecryptLast(bytes: self.accumulated.suffix(self.worker.additionalBufferSize))
        plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
      }
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize)
    }

    return plaintext
  }
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class AEADChaCha20Poly1305 : LinkaAPIKit.AEAD {
  public static let kLen: Swift.Int
  public static var ivRange: Swift.Range<Swift.Int>
  public static func encrypt(_ plainText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>) throws -> (cipherText: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>)
  public static func decrypt(_ cipherText: Swift.Array<Swift.UInt8>, key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>, authenticationHeader: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>) throws -> (plainText: Swift.Array<Swift.UInt8>, success: Swift.Bool)
  @objc deinit
}
open class DataTransform : LinkaAPIKit.TransformType {
  public typealias Object = Foundation.Data
  public typealias JSON = Swift.String
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.Data?
  open func transformToJSON(_ value: Foundation.Data?) -> Swift.String?
  @objc deinit
}
public struct CFB : LinkaAPIKit.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: LinkaAPIKit.CFB.Error, b: LinkaAPIKit.CFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum SegmentSize : Swift.Int {
    case cfb8
    case cfb128
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public let options: LinkaAPIKit.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, segmentSize: LinkaAPIKit.CFB.SegmentSize = .cfb128)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping LinkaAPIKit.CipherOperationOnBlock, encryptionOperation: @escaping LinkaAPIKit.CipherOperationOnBlock) throws -> LinkaAPIKit.CipherModeWorker
}
@objc @_inheritsConvenienceInitializers public class LinkaBLEPairingUpManager : ObjectiveC.NSObject, LinkaAPIKit.LinkaBLECentralManagerDelegate {
  public var peripheral: CoreBluetooth.CBPeripheral!
  public var manager: LinkaAPIKit.LinkaBLECentralManager!
  public var state: LinkaAPIKit.PairingUpState
  public var callback: ((_ peripheral: CoreBluetooth.CBPeripheral, _ error: Foundation.NSError?) -> Swift.Void)!
  public func startPairingUp(peripheral: CoreBluetooth.CBPeripheral, callback: @escaping (_ peripheral: CoreBluetooth.CBPeripheral, _ error: Foundation.NSError?) -> Swift.Void)
  public func connect()
  public func discoverServices()
  public func disconnect()
  public func done()
  public func linka_delegate_instance() -> Swift.AnyObject
  public func onBLEPoweredOn()
  public func onBLEPoweredOff()
  public func onConnectToPeripheral(peripheral: CoreBluetooth.CBPeripheral)
  public func onDisconnectToPeripheral(peripheral: CoreBluetooth.CBPeripheral, error: Foundation.NSError?)
  public func onFailToConnectPeripheral(peripheral: CoreBluetooth.CBPeripheral, error: Foundation.NSError?)
  public func onRefreshPeripheralObject(peripheral: CoreBluetooth.CBPeripheral, RSSI: Foundation.NSNumber!, error: Foundation.NSError?)
  public func onRefreshPeripheralServices(peripheral: CoreBluetooth.CBPeripheral)
  public func onCreateNotificationForPeripheralCharacteristic(peripheral: CoreBluetooth.CBPeripheral, characteristic: CoreBluetooth.CBCharacteristic, isConnected: Swift.Bool)
  public func onRefreshPeripheralCharacteristic(peripheral: CoreBluetooth.CBPeripheral, characteristic: CoreBluetooth.CBCharacteristic)
  @objc override dynamic public init()
  @objc deinit
}
@inlinable internal func rotateLeft(_ value: Swift.UInt8, by: Swift.UInt8) -> Swift.UInt8 {
  ((value << by) & 0xff) | (value >> (8 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  ((value << by) & 0xffff) | (value >> (16 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  ((value << by) & 0xffffffff) | (value >> (32 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  (value << by) | (value >> (64 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  (value >> by) | (value << (16 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  (value >> by) | (value << (32 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  ((value >> by) | (value << (64 - by)))
}
@inlinable internal func reversed(_ uint8: Swift.UInt8) -> Swift.UInt8 {
  var v = uint8
  v = (v & 0xf0) >> 4 | (v & 0x0f) << 4
  v = (v & 0xcc) >> 2 | (v & 0x33) << 2
  v = (v & 0xaa) >> 1 | (v & 0x55) << 1
  return v
}
@inlinable internal func reversed(_ uint32: Swift.UInt32) -> Swift.UInt32 {
  var v = uint32
  v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1)
  v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2)
  v = ((v >> 4) & 0x0f0f0f0f) | ((v & 0x0f0f0f0f) << 4)
  v = ((v >> 8) & 0x00ff00ff) | ((v & 0x00ff00ff) << 8)
  v = ((v >> 16) & 0xffff) | ((v & 0xffff) << 16)
  return v
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.ArraySlice<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  return xor(left, right).slice
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.Array<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  let length = Swift.min(left.count, right.count)

  let buf = UnsafeMutablePointer<UInt8>.allocate(capacity: length)
  buf.initialize(repeating: 0, count: length)
  defer {
    buf.deinitialize(count: length)
    buf.deallocate()
  }

  // xor
  for i in 0..<length {
    buf[i] = left[left.startIndex.advanced(by: i)] ^ right[right.startIndex.advanced(by: i)]
  }

  return Array(UnsafeBufferPointer(start: buf, count: length))
}
@inline(__always) @inlinable internal func bitPadding(to data: inout Swift.Array<Swift.UInt8>, blockSize: Swift.Int, allowance: Swift.Int = 0) {
  let msgLength = data.count
  // Step 1. Append Padding Bits
  // append one bit (UInt8 with one bit) to message
  data.append(0x80)

  // Step 2. append "0" bit until message length in bits â‰¡ 448 (mod 512)
  let max = blockSize - allowance // 448, 986
  if msgLength % blockSize < max { // 448
    data += Array<UInt8>(repeating: 0, count: max - 1 - (msgLength % blockSize))
  } else {
    data += Array<UInt8>(repeating: 0, count: blockSize + max - 1 - (msgLength % blockSize))
  }
}
public struct MapError : Swift.Error {
  public var key: Swift.String?
  public var currentValue: Any?
  public var reason: Swift.String?
  public var file: Swift.StaticString?
  public var function: Swift.StaticString?
  public var line: Swift.UInt?
  public init(key: Swift.String?, currentValue: Any?, reason: Swift.String?, file: Swift.StaticString? = nil, function: Swift.StaticString? = nil, line: Swift.UInt? = nil)
}
extension LinkaAPIKit.MapError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public enum PKCS7 {
}
public protocol ImmutableMappable : LinkaAPIKit.BaseMappable {
  init(map: LinkaAPIKit.Map) throws
}
extension LinkaAPIKit.ImmutableMappable {
  public func mapping(map: LinkaAPIKit.Map)
  public init(JSONString: Swift.String, context: LinkaAPIKit.MapContext? = nil) throws
  public init(JSON: [Swift.String : Any], context: LinkaAPIKit.MapContext? = nil) throws
  public init(JSONObject: Any, context: LinkaAPIKit.MapContext? = nil) throws
}
extension LinkaAPIKit.Map {
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> Transform.Object where Transform : LinkaAPIKit.TransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T] where T : Swift.RawRepresentable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> T where T : LinkaAPIKit.BaseMappable
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [T] where T : LinkaAPIKit.BaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Transform.Object] where Transform : LinkaAPIKit.TransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : T] where T : LinkaAPIKit.BaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [Swift.String : Transform.Object] where Transform : LinkaAPIKit.TransformType
  final public func value<T>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[T]] where T : LinkaAPIKit.BaseMappable
  final public func value<Transform>(_ key: Swift.String, nested: Swift.Bool? = nil, delimiter: Swift.String = ".", using transform: Transform, file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) throws -> [[Transform.Object]] where Transform : LinkaAPIKit.TransformType
}
extension LinkaAPIKit.Mapper where N : LinkaAPIKit.ImmutableMappable {
  final public func map(JSON: [Swift.String : Any]) throws -> N
  final public func map(JSONString: Swift.String) throws -> N
  final public func map(JSONObject: Any) throws -> N
  final public func mapArray(JSONArray: [[Swift.String : Any]]) throws -> [N]
  final public func mapArray(JSONString: Swift.String) throws -> [N]
  final public func mapArray(JSONObject: Any) throws -> [N]
  final public func mapDictionary(JSONString: Swift.String) throws -> [Swift.String : N]
  final public func mapDictionary(JSONObject: Any?) throws -> [Swift.String : N]
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]]) throws -> [Swift.String : N]
  final public func mapDictionaryOfArrays(JSONObject: Any?) throws -> [Swift.String : [N]]
  final public func mapDictionaryOfArrays(JSON: [Swift.String : [[Swift.String : Any]]]) throws -> [Swift.String : [N]]
  final public func mapArrayOfArrays(JSONObject: Any?) throws -> [[N]]
}
final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: LinkaAPIKit.ChaCha20.Error, b: LinkaAPIKit.ChaCha20.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension LinkaAPIKit.ChaCha20 : LinkaAPIKit.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension LinkaAPIKit.ChaCha20 {
  public struct ChaChaEncryptor : LinkaAPIKit.Cryptor, LinkaAPIKit.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension LinkaAPIKit.ChaCha20 {
  public struct ChaChaDecryptor : LinkaAPIKit.Cryptor, LinkaAPIKit.Updatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension LinkaAPIKit.ChaCha20 : LinkaAPIKit.Cryptors {
  final public func makeEncryptor() -> LinkaAPIKit.Cryptor & LinkaAPIKit.Updatable
  final public func makeDecryptor() -> LinkaAPIKit.Cryptor & LinkaAPIKit.Updatable
}
public protocol TransformType {
  associatedtype Object
  associatedtype JSON
  func transformFromJSON(_ value: Any?) -> Self.Object?
  func transformToJSON(_ value: Self.Object?) -> Self.JSON?
}
public enum AtCommand : Swift.UInt8 {
  case ATC_NONE
  case ATC_GET_IMSI
  case ATC_SETUP_GNSS
  case ATC_SETUP_LTE
  case ATC_ON
  case ATC_OFF
  case ATC_START_LOC
  case ATC_STOP_LOC
  case ATC_CONN_INFO
  case ATC_START_CELL_LOC
  case ATC_DATA_ON
  case ATC_DATA_OFF
  case ATC_RESET
  case ATC_TEST_1
  case ATC_TEST_2
  case ATC_TEST_3
  case ATC_TEST_4
  case ATC_TEST_5
  case ATC_TEST_6
  case ATC_TEST_7
  case ATC_TEST_8
  case ATC_TEST_9
  case ATC_TEST_10
  case ATC_TEST_11
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum PKCS5 {
}
public protocol BaseMappable {
  mutating func mapping(map: LinkaAPIKit.Map)
}
public protocol Mappable : LinkaAPIKit.BaseMappable {
  init?(map: LinkaAPIKit.Map)
}
public protocol StaticMappable : LinkaAPIKit.BaseMappable {
  static func objectForMapping(map: LinkaAPIKit.Map) -> LinkaAPIKit.BaseMappable?
}
extension LinkaAPIKit.BaseMappable {
  public init?(JSONString: Swift.String, context: LinkaAPIKit.MapContext? = nil)
  public init?(JSON: [Swift.String : Any], context: LinkaAPIKit.MapContext? = nil)
  public func toJSON() -> [Swift.String : Any]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
extension Swift.Array where Element : LinkaAPIKit.BaseMappable {
  public init?(JSONString: Swift.String, context: LinkaAPIKit.MapContext? = nil)
  public init(JSONArray: [[Swift.String : Any]], context: LinkaAPIKit.MapContext? = nil)
  public func toJSON() -> [[Swift.String : Any]]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
extension Swift.Set where Element : LinkaAPIKit.BaseMappable {
  public init?(JSONString: Swift.String, context: LinkaAPIKit.MapContext? = nil)
  public init?(JSONArray: [[Swift.String : Any]], context: LinkaAPIKit.MapContext? = nil)
  public func toJSON() -> [[Swift.String : Any]]
  public func toJSONString(prettyPrint: Swift.Bool = false) -> Swift.String?
}
@usableFromInline
final internal class StreamDecryptor : LinkaAPIKit.Cryptor, LinkaAPIKit.Updatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: LinkaAPIKit.CipherModeWorker
  @usableFromInline
  final internal let padding: LinkaAPIKit.Padding
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: LinkaAPIKit.Padding, _ worker: LinkaAPIKit.CipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    let toProcess = self.accumulated.prefix(max(self.accumulated.count - self.worker.additionalBufferSize, 0))

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      // will truncate suffix if needed
      try finalizingWorker.willDecryptLast(bytes: self.accumulated.slice)
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: bytes.count + self.worker.additionalBufferSize)
    for chunk in toProcess.batched(by: self.blockSize) {
      plaintext += self.worker.decrypt(block: chunk)
      processedBytesCount += chunk.count
    }

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = plaintext.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    self.accumulated.removeFirst(processedBytesCount) // super-slow

    if var finalizingWorker = worker as? FinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.finalize(decrypt: plaintext.slice))
    }

    return plaintext
  }
  @inlinable final public func seek(to position: Swift.Int) throws {
    guard var worker = self.worker as? SeekableModeWorker else {
      fatalError("Not supported")
    }

    try worker.seek(to: position)
    self.worker = worker
  }
  @objc @usableFromInline
  deinit
}
extension Foundation.DateFormatter {
  convenience public init(withFormat format: Swift.String, locale: Swift.String)
}
open class ISO8601DateTransform : LinkaAPIKit.DateFormatterTransform {
  public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objcMembers public class LinkaMerchantlockAPIResponseMapping : LinkaAPIKit.LinkaAPIResponse {
  public var data: LinkaAPIKit.LinkaMerchantlockAPIResponseDataMapping?
  override public func mapping(map: LinkaAPIKit.Map)
  required public init?(map: LinkaAPIKit.Map)
  @objc deinit
}
@_inheritsConvenienceInitializers @objcMembers public class LinkaMerchantlockListAPIResponseMapping : LinkaAPIKit.LinkaAPIResponse {
  public var data: [LinkaAPIKit.LinkaMerchantlockAPIResponseDataMapping]?
  override public func mapping(map: LinkaAPIKit.Map)
  required public init?(map: LinkaAPIKit.Map)
  @objc deinit
}
@objcMembers public class LinkaMerchantlockAPIResponseDataMapping : LinkaAPIKit.Mappable {
  @objc public var _id: Swift.String?
  @objc public var merchant_id: Swift.String?
  @objc public var lock_serial_no: Swift.String?
  public var is_locked: Swift.Bool?
  public var is_suspended: Swift.Bool?
  public var is_key_registered: Swift.Bool?
  public var is_key_revoked: Swift.Bool?
  @objc public var createdAt: Swift.String?
  @objc public var modifiedAt: Swift.String?
  public var removed: Swift.Bool?
  @objc public var name: Swift.String?
  public var latitude: Swift.Double?
  public var longitude: Swift.Double?
  @objc public var configuration_Settings: [Swift.String : Swift.Int]
  @objc public var lock_type: Swift.String?
  @objc public var lastCellPing: Swift.String?
  @objc public var deploy_state: Swift.String?
  public var active: Swift.Bool?
  public var maintenance_required: Swift.Bool?
  public var recovery_mode: Swift.Bool?
  @objc public var keyfob: Swift.String?
  required public init?(map: LinkaAPIKit.Map)
  public func mapping(map: LinkaAPIKit.Map)
  @objc deinit
}
@usableFromInline
internal struct BatchedCollectionIndex<Base> where Base : Swift.Collection {
}
extension LinkaAPIKit.BatchedCollectionIndex : Swift.Comparable {
  @usableFromInline
  internal static func == <Base>(lhs: LinkaAPIKit.BatchedCollectionIndex<Base>, rhs: LinkaAPIKit.BatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
  @usableFromInline
  internal static func < <Base>(lhs: LinkaAPIKit.BatchedCollectionIndex<Base>, rhs: LinkaAPIKit.BatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
}
@usableFromInline
internal struct BatchedCollection<Base> : Swift.Collection where Base : Swift.Collection {
  @usableFromInline
  internal init(base: Base, size: Swift.Int)
  @usableFromInline
  internal typealias Index = LinkaAPIKit.BatchedCollectionIndex<Base>
  @usableFromInline
  internal var startIndex: LinkaAPIKit.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal var endIndex: LinkaAPIKit.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal func index(after idx: LinkaAPIKit.BatchedCollection<Base>.Index) -> LinkaAPIKit.BatchedCollection<Base>.Index
  @usableFromInline
  internal subscript(idx: LinkaAPIKit.BatchedCollection<Base>.Index) -> Base.SubSequence {
    get
  }
  @usableFromInline
  internal typealias Element = Base.SubSequence
  @usableFromInline
  internal typealias Indices = Swift.DefaultIndices<LinkaAPIKit.BatchedCollection<Base>>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<LinkaAPIKit.BatchedCollection<Base>>
  @usableFromInline
  internal typealias SubSequence = Swift.Slice<LinkaAPIKit.BatchedCollection<Base>>
}
extension Swift.Collection {
  @inlinable internal func batched(by size: Swift.Int) -> LinkaAPIKit.BatchedCollection<Self> {
    BatchedCollection(base: self, size: size)
  }
}
@objc @_hasMissingDesignatedInitializers public class LockInfoPacket : LinkaAPIKit.LockDataPacket {
  public var mLockState: LinkaAPIKit.LockState
  public var m_RSSI: Swift.Int
  public var mUptime_s: Swift.UInt
  public var m_nAccel_x: Swift.UInt
  public var m_nAccel_y: Swift.UInt
  public var m_nAccel_z: Swift.UInt
  public var mAccel_x: Swift.Double
  public var mAccel_y: Swift.Double
  public var mAccel_z: Swift.Double
  public var mActivityFlags: Swift.UInt
  public var mBootloaderVersion: Swift.UInt
  public var mSpare: Swift.UInt
  public var m_usCRC: Swift.UInt
  public func GetLockStateRepresentation() -> Swift.String
  public func GetLockState() -> LinkaAPIKit.LockState
  @objc deinit
}
final public class Poly1305 : LinkaAPIKit.Authenticator {
  public enum Error : Swift.Error {
    case authenticateError
    public static func == (a: LinkaAPIKit.Poly1305.Error, b: LinkaAPIKit.Poly1305.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension LinkaAPIKit.AES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: LinkaAPIKit.Padding = .pkcs7) throws
}
final public class SHA2 {
  @usableFromInline
  final internal let variant: LinkaAPIKit.SHA2.Variant
  @usableFromInline
  final internal let size: Swift.Int
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let digestLength: Swift.Int
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash32: [Swift.UInt32]
  @usableFromInline
  final internal var accumulatedHash64: [Swift.UInt64]
  @frozen public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: LinkaAPIKit.SHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: LinkaAPIKit.SHA2.Variant.RawValue)
    @usableFromInline
    internal var h: Swift.Array<Swift.UInt64> {
      get
    }
    @usableFromInline
    internal var finalLength: Swift.Int {
      get
    }
  }
  public init(variant: LinkaAPIKit.SHA2.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process64(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @usableFromInline
  final internal func process32(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt32>)
  @objc deinit
}
extension LinkaAPIKit.SHA2 : LinkaAPIKit.Updatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: self.blockSize / 8) // A 64-bit/128-bit representation of b. blockSize fit by accident.

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: self.blockSize, allowance: self.blockSize / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        switch self.variant {
          case .sha224, .sha256:
            self.process32(block: chunk, currentHash: &self.accumulatedHash32)
          case .sha384, .sha512:
            self.process64(block: chunk, currentHash: &self.accumulatedHash64)
          }
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: variant.digestLength)
    switch self.variant {
      case .sha224, .sha256:
        var pos = 0
        for idx in 0..<self.accumulatedHash32.count where idx < self.variant.finalLength {
          let h = accumulatedHash32[idx]
          result[pos + 0] = UInt8((h >> 24) & 0xff)
          result[pos + 1] = UInt8((h >> 16) & 0xff)
          result[pos + 2] = UInt8((h >> 8) & 0xff)
          result[pos + 3] = UInt8(h & 0xff)
          pos += 4
        }
      case .sha384, .sha512:
        var pos = 0
        for idx in 0..<self.accumulatedHash64.count where idx < self.variant.finalLength {
          let h = accumulatedHash64[idx]
          result[pos + 0] = UInt8((h >> 56) & 0xff)
          result[pos + 1] = UInt8((h >> 48) & 0xff)
          result[pos + 2] = UInt8((h >> 40) & 0xff)
          result[pos + 3] = UInt8((h >> 32) & 0xff)
          result[pos + 4] = UInt8((h >> 24) & 0xff)
          result[pos + 5] = UInt8((h >> 16) & 0xff)
          result[pos + 6] = UInt8((h >> 8) & 0xff)
          result[pos + 7] = UInt8(h & 0xff)
          pos += 8
        }
    }

    // reset hash value for instance
    if isLast {
      switch self.variant {
        case .sha224, .sha256:
          self.accumulatedHash32 = self.variant.h.lazy.map { UInt32($0) } // FIXME: UInt64 for process64
        case .sha384, .sha512:
          self.accumulatedHash64 = self.variant.h
      }
    }

    return result
  }
}
@objc @_inheritsConvenienceInitializers open class SystemFlags : ObjectiveC.NSObject {
  public static let VLS_FLAG_RADIO_EV: (Swift.UInt)
  public static let VLS_FLAG_TETHER: (Swift.UInt)
  public static let VLS_FLAG_CHARGING: (Swift.UInt)
  public static let VLS_FLAG_CHARGED: (Swift.UInt)
  public static let VLS_FLAG_BATT_LO: (Swift.UInt)
  public static let VLS_FLAG_STALL: (Swift.UInt)
  public static let VLS_FLAG_ALARM_BUMP: (Swift.UInt)
  public static let VLS_FLAG_ALARM_TEMP: (Swift.UInt)
  public static let VLS_FLAG_ALERT: (Swift.UInt)
  public static let VLS_FLAG_ALARM_TIP: (Swift.UInt)
  public static let VLS_FLAG_CONNECTED: (Swift.UInt)
  public static let VLS_FLAG_HFCLK: (Swift.UInt)
  public static let VLS_FLAG_CYCLE_TEST_MODE: (Swift.UInt)
  public static let VLS_FLAG_1S_ACCEL_LO_ACTIVITY: (Swift.UInt)
  public static let VLS_FLAG_HALL_ANOMALY: (Swift.UInt)
  public static let VLS_FLAG_ALARM_HAMMER: (Swift.UInt)
  public static let VLS_FLAG_ALARM_JOSTLE: (Swift.UInt)
  public static let VLS_FLAG_SIREN_ACTIVE: (Swift.UInt)
  public static let VLS_FLAG_INVALID_PAC: (Swift.UInt)
  public static let VLS_FLAG_BAD_PAC_ENTRY: (Swift.UInt)
  public static let VLS_FLAG_BEEPER_ACTIVE: (Swift.UInt)
  public static let VLS_FLAG_ACCEL_SUPPRESS: (Swift.UInt)
  public static let VLS_FLAG_LOW_TEMP: (Swift.UInt)
  public static let VLS_FLAG_BOND_REQ: (Swift.UInt)
  public static let VLS_FLAG_ENC_V2: (Swift.UInt)
  public static let VLS_FLAG_ENC_V3: (Swift.UInt)
  public static let VLS_FLAG_PENDING_SLEEP: (Swift.UInt)
  public static let VLS_FLAG_IGNORE_HALL: (Swift.UInt)
  public static let VLS_FLAG_ES_BRIDGE: (Swift.UInt)
  public static let VLS_FLAG_RFIDMODE: (Swift.UInt)
  public static let VLS_FLAG_48VCONV: (Swift.UInt)
  public static func flagsToString(_ nLockFlags: Swift.UInt) -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
extension Swift.FixedWidthInteger {
  @inlinable internal func bytes(totalBytes: Swift.Int = MemoryLayout<Self>.size) -> Swift.Array<Swift.UInt8> {
    arrayOfBytes(value: self.littleEndian, length: totalBytes)
    // TODO: adjust bytes order
    // var value = self.littleEndian
    // return withUnsafeBytes(of: &value, Array.init).reversed()
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String
  public init(base64: Swift.String)
}
extension Swift.Array {
  @inlinable internal init(reserveCapacity: Swift.Int) {
    self = Array<Element>()
    self.reserveCapacity(reserveCapacity)
  }
  @inlinable internal var slice: Swift.ArraySlice<Element> {
    get {
    self[self.startIndex ..< self.endIndex]
  }
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Swift.Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: LinkaAPIKit.SHA2.Variant) -> [Element]
  public func sha3(_ variant: LinkaAPIKit.SHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: LinkaAPIKit.Cipher) throws -> [Element]
  public func decrypt(cipher: LinkaAPIKit.Cipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : LinkaAPIKit.Authenticator
}
@objc @_hasMissingDesignatedInitializers public class LockDataPacket : ObjectiveC.NSObject {
  public class func updatePacketCrc(packet: [LinkaAPIKit.Byte]!) -> [LinkaAPIKit.Byte]
  public func setPacketCrc(crc: Swift.UInt)
  public func getPacketCrc() -> Swift.UInt
  public class func getPacketCrc(packet: [LinkaAPIKit.Byte]!) -> Swift.UInt
  public class func checkPacketCRC(packet: [LinkaAPIKit.Byte]!) -> Swift.Bool
  public func getPayload() -> [LinkaAPIKit.Byte]
  public static func sBytesToULONG(lsb: LinkaAPIKit.Byte, _b1: LinkaAPIKit.Byte, _b2: LinkaAPIKit.Byte, msb: LinkaAPIKit.Byte) -> Swift.UInt32
  @objc deinit
}
extension Swift.UInt64 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt64(bytes[index.advanced(by: 0)]) << 56 : 0
    let val1 = count > 1 ? UInt64(bytes[index.advanced(by: 1)]) << 48 : 0
    let val2 = count > 2 ? UInt64(bytes[index.advanced(by: 2)]) << 40 : 0
    let val3 = count > 3 ? UInt64(bytes[index.advanced(by: 3)]) << 32 : 0
    let val4 = count > 4 ? UInt64(bytes[index.advanced(by: 4)]) << 24 : 0
    let val5 = count > 5 ? UInt64(bytes[index.advanced(by: 5)]) << 16 : 0
    let val6 = count > 6 ? UInt64(bytes[index.advanced(by: 6)]) << 8 : 0
    let val7 = count > 7 ? UInt64(bytes[index.advanced(by: 7)]) : 0

    self = val0 | val1 | val2 | val3 | val4 | val5 | val6 | val7
  }
}
public enum MappingType {
  case fromJSON
  case toJSON
  public static func == (a: LinkaAPIKit.MappingType, b: LinkaAPIKit.MappingType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class Mapper<N> where N : LinkaAPIKit.BaseMappable {
  final public var context: LinkaAPIKit.MapContext?
  final public var shouldIncludeNilValues: Swift.Bool
  public init(context: LinkaAPIKit.MapContext? = nil, shouldIncludeNilValues: Swift.Bool = false)
  final public func map(JSONObject: Any?, toObject object: N) -> N
  final public func map(JSONString: Swift.String, toObject object: N) -> N
  final public func map(JSON: [Swift.String : Any], toObject object: N) -> N
  final public func map(JSONString: Swift.String) -> N?
  final public func map(JSONObject: Any?) -> N?
  final public func map(JSON: [Swift.String : Any]) -> N?
  final public func mapArray(JSONString: Swift.String) -> [N]?
  final public func mapArray(JSONObject: Any?) -> [N]?
  final public func mapArray(JSONArray: [[Swift.String : Any]]) -> [N]
  final public func mapDictionary(JSONString: Swift.String) -> [Swift.String : N]?
  final public func mapDictionary(JSONObject: Any?) -> [Swift.String : N]?
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]]) -> [Swift.String : N]?
  final public func mapDictionary(JSONObject: Any?, toDictionary dictionary: [Swift.String : N]) -> [Swift.String : N]
  final public func mapDictionary(JSON: [Swift.String : [Swift.String : Any]], toDictionary dictionary: [Swift.String : N]) -> [Swift.String : N]
  final public func mapDictionaryOfArrays(JSONObject: Any?) -> [Swift.String : [N]]?
  final public func mapDictionaryOfArrays(JSON: [Swift.String : [[Swift.String : Any]]]) -> [Swift.String : [N]]?
  final public func mapArrayOfArrays(JSONObject: Any?) -> [[N]]?
  public static func parseJSONStringIntoDictionary(JSONString: Swift.String) -> [Swift.String : Any]?
  public static func parseJSONString(JSONString: Swift.String) -> Any?
  @objc deinit
}
extension LinkaAPIKit.Mapper {
  final public func map(JSONfile: Swift.String) -> N?
  final public func mapArray(JSONfile: Swift.String) -> [N]?
}
extension LinkaAPIKit.Mapper {
  final public func toJSON(_ object: N) -> [Swift.String : Any]
  final public func toJSONArray(_ array: [N]) -> [[Swift.String : Any]]
  final public func toJSONDictionary(_ dictionary: [Swift.String : N]) -> [Swift.String : [Swift.String : Any]]
  final public func toJSONDictionaryOfArrays(_ dictionary: [Swift.String : [N]]) -> [Swift.String : [[Swift.String : Any]]]
  final public func toJSONString(_ object: N, prettyPrint: Swift.Bool = false) -> Swift.String?
  final public func toJSONString(_ array: [N], prettyPrint: Swift.Bool = false) -> Swift.String?
  public static func toJSONString(_ JSONObject: Any, prettyPrint: Swift.Bool) -> Swift.String?
  public static func toJSONData(_ JSONObject: Any, options: Foundation.JSONSerialization.WritingOptions) -> Foundation.Data?
}
extension LinkaAPIKit.Mapper where N : Swift.Hashable {
  final public func mapSet(JSONString: Swift.String) -> Swift.Set<N>?
  final public func mapSet(JSONObject: Any?) -> Swift.Set<N>?
  final public func mapSet(JSONArray: [[Swift.String : Any]]) -> Swift.Set<N>
  final public func toJSONSet(_ set: Swift.Set<N>) -> [[Swift.String : Any]]
  final public func toJSONString(_ set: Swift.Set<N>, prettyPrint: Swift.Bool = false) -> Swift.String?
}
@objcMembers public class LinkaAPIResponse : LinkaAPIKit.Mappable {
  @objc public var status: Swift.String?
  @objc public var message: Swift.String?
  @objc public var statusCode: Swift.Int
  required public init?(map: LinkaAPIKit.Map)
  public func mapping(map: LinkaAPIKit.Map)
  @objc deinit
}
public enum PRIV_LEVEL : Swift.UInt8 {
  case priv_NONE
  case priv_ADMIN
  case priv_USER
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
@usableFromInline
final internal class BlockEncryptor : LinkaAPIKit.Cryptor, LinkaAPIKit.Updatable {
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: LinkaAPIKit.Padding, _ worker: LinkaAPIKit.CipherModeWorker) throws
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
extension Swift.UInt32 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt32(bytes[index.advanced(by: 0)]) << 24 : 0
    let val1 = count > 1 ? UInt32(bytes[index.advanced(by: 1)]) << 16 : 0
    let val2 = count > 2 ? UInt32(bytes[index.advanced(by: 2)]) << 8 : 0
    let val3 = count > 3 ? UInt32(bytes[index.advanced(by: 3)]) : 0

    self = val0 | val1 | val2 | val3
  }
}
open class CustomDateFormatTransform : LinkaAPIKit.DateFormatterTransform {
  public init(formatString: Swift.String)
  @objc deinit
}
public typealias OnFetchLockStatusPacket_API = (_ peripheral: CoreBluetooth.CBPeripheral, _ lockStatusPacket: LinkaAPIKit.LockStatusPacket?, _ error: Foundation.NSError?) -> (Swift.Void)
public typealias OnFetchLockSettingPacket_API = (_ peripheral: CoreBluetooth.CBPeripheral, _ lockSettingPacket: LinkaAPIKit.LockSettingPacket?, _ error: Foundation.NSError?) -> (Swift.Void)
public typealias OnFetchLockContextPacket_API = (_ peripheral: CoreBluetooth.CBPeripheral, _ lockContextPacket: LinkaAPIKit.LockContextPacket?, _ error: Foundation.NSError?) -> (Swift.Void)
public typealias OnFetchLockInfoPacket_API = (_ peripheral: CoreBluetooth.CBPeripheral, _ lockInfoPacket: LinkaAPIKit.LockInfoPacket?, _ error: Foundation.NSError?) -> (Swift.Void)
public typealias OnFetchFirmwareVersion_API = (_ firmware: Swift.String) -> (Swift.Void)
public typealias OnFetchLockStatusPacket = (_ peripheral: CoreBluetooth.CBPeripheral, _ lockStatusPacket: LinkaAPIKit.LockStatusPacket?, _ error: Foundation.NSError?) -> (Swift.Void)
public typealias OnFetchLockSettingPacket = (_ peripheral: CoreBluetooth.CBPeripheral, _ lockSettingPacket: LinkaAPIKit.LockSettingPacket?, _ error: Foundation.NSError?) -> (Swift.Void)
public typealias OnFetchLockContextPacket = (_ peripheral: CoreBluetooth.CBPeripheral, _ lockContextPacket: LinkaAPIKit.LockContextPacket?, _ error: Foundation.NSError?) -> (Swift.Void)
public typealias OnFetchLockInfoPacket = (_ peripheral: CoreBluetooth.CBPeripheral, _ lockInfoPacket: LinkaAPIKit.LockInfoPacket?, _ error: Foundation.NSError?) -> (Swift.Void)
public typealias OnLockSettled = () -> (Swift.Void)
public typealias OnLockBlocked = (_ periperhal: CoreBluetooth.CBPeripheral) -> Swift.Void
@_hasMissingDesignatedInitializers public class AccelerometerSensitivitySetting {
  public static let ACCEL_SENSITIVITY_EXTRA_SENSITIVE: Swift.Int
  public static let ACCEL_SENSITIVITY_OFF: Swift.Int
  public static let ACCEL_SENSITIVITY_LEO_NEW_FIRMWARE: Swift.Int
  public static let ACCEL_SENSITIVITY_NORMAL: Swift.Int
  @objc deinit
}
@objc @objcMembers public class LinkaBLECommunicationManager : ObjectiveC.NSObject, LinkaAPIKit.LinkaBLECentralManagerDelegate, CoreLocation.CLLocationManagerDelegate {
  @objc public func getFwVersionNumber() -> Swift.Double
  @objc public var peripheral: CoreBluetooth.CBPeripheral!
  @objc public var onFetchLockStatusPacket_API: LinkaAPIKit.OnFetchLockStatusPacket_API!
  @objc public var onFetchLockSettingPacket_API: LinkaAPIKit.OnFetchLockSettingPacket_API!
  @objc public var onFetchLockContextPacket_API: LinkaAPIKit.OnFetchLockContextPacket_API!
  @objc public var onFetchLockInfoPacket_API: LinkaAPIKit.OnFetchLockInfoPacket_API!
  @objc public var onFetchLockTamperWarning_API: LinkaAPIKit.OnFetchLockStatusPacket_API!
  @objc public var onFetchLockBatteryLowWarning_API: LinkaAPIKit.OnFetchLockStatusPacket_API!
  @objc public var onFetchLockBatteryCriticallyLowWarning_API: LinkaAPIKit.OnFetchLockStatusPacket_API!
  @objc public var onFetchFirmwareVersion_API: LinkaAPIKit.OnFetchFirmwareVersion_API!
  @objc public var onLockBlocked_API: LinkaAPIKit.OnLockBlocked?
  @objc public var onFetchLockStatusPacket: LinkaAPIKit.OnFetchLockStatusPacket!
  @objc public var onFetchLockSettingPacket: LinkaAPIKit.OnFetchLockSettingPacket!
  @objc public var onFetchLockContextPacket: LinkaAPIKit.OnFetchLockContextPacket!
  @objc public var onFetchLockInfoPacket: LinkaAPIKit.OnFetchLockInfoPacket!
  @objc public var onFetchLockTamperWarning: LinkaAPIKit.OnFetchLockStatusPacket!
  @objc public var onFetchLockBatteryLowWarning: LinkaAPIKit.OnFetchLockStatusPacket!
  @objc public var onFetchLockBatteryCriticallyLowWarning: LinkaAPIKit.OnFetchLockStatusPacket!
  @objc public var onLockSettled: LinkaAPIKit.OnLockSettled!
  @objc public var output: Swift.String
  @objc public var isButtonUsedForLocking: Swift.Bool
  public var lastUptimePacket: Swift.UInt!
  @objc public var uptimePacketDidChange: Swift.Bool
  @objc public var isEncryptionCounterValid: Swift.Bool
  public enum AlarmSensitivity {
    case GARAGE
    case SUBURBAN
    case METRO
    public static func == (a: LinkaAPIKit.LinkaBLECommunicationManager.AlarmSensitivity, b: LinkaAPIKit.LinkaBLECommunicationManager.AlarmSensitivity) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc public init(isDebug: Swift.Bool, view: UIKit.UIView!)
  @objc public init(isDebug: Swift.Bool, view: UIKit.UIView!, masterKey: [LinkaAPIKit.Byte]!, keyIndex: Swift.UInt)
  public init(isDebug: Swift.Bool, view: UIKit.UIView!, subKey: [LinkaAPIKit.Byte]!, keyIndex: Swift.UInt, priv_level: LinkaAPIKit.PRIV_LEVEL)
  @objc public func startCommunication(peripheral: CoreBluetooth.CBPeripheral, onFetchLockStatusPacket_API: LinkaAPIKit.OnFetchLockStatusPacket_API!, onFetchLockSettingPacket_API: LinkaAPIKit.OnFetchLockSettingPacket_API!, onFetchLockContextPacket_API: LinkaAPIKit.OnFetchLockContextPacket_API!, onFetchLockInfoPacket_API: LinkaAPIKit.OnFetchLockInfoPacket_API!, onFetchLockTamperWarning_API: LinkaAPIKit.OnFetchLockStatusPacket_API!, onFetchLockBatteryLowWarning_API: LinkaAPIKit.OnFetchLockStatusPacket_API!, onFetchLockBatteryCriticallyLowWarning_API: LinkaAPIKit.OnFetchLockStatusPacket_API!, onFetchFirmwareVersion_API: LinkaAPIKit.OnFetchFirmwareVersion_API!, onFetchLockStatusPacket: LinkaAPIKit.OnFetchLockStatusPacket!, onFetchLockSettingPacket: LinkaAPIKit.OnFetchLockSettingPacket!, onFetchLockContextPacket: LinkaAPIKit.OnFetchLockContextPacket!, onFetchLockInfoPacket: LinkaAPIKit.OnFetchLockInfoPacket!, onFetchLockTamperWarning: LinkaAPIKit.OnFetchLockStatusPacket!, onFetchLockBatteryLowWarning: LinkaAPIKit.OnFetchLockStatusPacket!, onFetchLockBatteryCriticallyLowWarning: LinkaAPIKit.OnFetchLockStatusPacket!, onLockSettled: LinkaAPIKit.OnLockSettled!)
  @objc public func stopCommunication()
  @objc public func doAction_SetUnlockedBumpThreshold(shouldAllowLockingMovement: Swift.Int) -> Swift.Bool
  public func doSetAlarmSensitivity(sensitivity: LinkaAPIKit.LinkaBLECommunicationManager.AlarmSensitivity) -> Swift.Bool
  @objc public func doAction_Bond() -> Swift.Bool
  @objc public func doAction_Lock() -> Swift.Bool
  @objc public func doAction_Unlock() -> Swift.Bool
  @objc public func clearEncryptedPacketQueue()
  @objc public func doAction_setTrackDuration(duration: Swift.Int) -> Swift.Bool
  @objc public func doAction_setFactorySetting() -> Swift.Bool
  @objc public func doAction_readFactorySetting() -> Swift.Bool
  @objc public func doAction_StartTracking() -> Swift.Bool
  @objc public func doAction_StatePing() -> Swift.Bool
  @objc public func doAction_StopTracking() -> Swift.Bool
  @objc public func doAction_ATC_Off() -> Swift.Bool
  @objc public func doAction_ATC_Gps() -> Swift.Bool
  @objc public func doAction_ATC_Conn() -> Swift.Bool
  @objc public func doAction_ATC_On() -> Swift.Bool
  @objc public func doAction_ATC_SetupLte() -> Swift.Bool
  @objc public func clearLog()
  @objc public func doAction_DefaultSettings() -> Swift.Bool
  @objc public func doAction_FwUpg() -> Swift.Bool
  @objc public func doAction_Authenticate() -> Swift.Bool
  @objc public func doAction_ReadAudioSetting() -> Swift.Bool
  @objc public func doRead_GpsOffSetting() -> Swift.Bool
  @objc public func doAction_ReadKeyfob() -> Swift.Bool
  @objc public func doAction_WriteKeyfob(keyfob: Swift.UInt64, uuid0: Swift.UInt64, uuid1: Swift.UInt64, major: Swift.Int, minor: Swift.Int)
  @objc public func doReadOperatorSettings()
  @objc public func doAction_WriteAudioSetting(setting: Swift.Int) -> Swift.Bool
  @objc public func doAction_Tune() -> Swift.Bool
  @objc public func doAction_Sleep() -> Swift.Bool
  @objc public func doAction_ResetReboot() -> Swift.Bool
  @objc public func doAction_GetPasscode() -> Swift.Bool
  @objc public func doAction_SetPasscode(passcode: Swift.String) -> Swift.Bool
  @objc public func doAction_GetLockSleep() -> Swift.Bool
  @objc public func doAction_SetLockSleep(sleepSeconds: Swift.String) -> Swift.Bool
  @objc public func doAction_GetUnlockedDisconnectedSleep() -> Swift.Bool
  @objc public func doAction_SetUnlockedDisconnectedSleep(sleepSeconds: Swift.String) -> Swift.Bool
  @objc public func doAction_SetTheftInterval(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetTheftDuration(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetUnlockInterval(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetLockInterval(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetLoopControl(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetGnssMode(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetGnssFilter(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetStatePing(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetFullGps(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetUnlockBattery(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetLockBattery(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetDisconnectedLock(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetNetworkCode(setting: Swift.Int) -> Swift.Bool
  @objc public func doAction_SetIpAddress(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetRemoteCommands(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetpowerButtonPing(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetTether(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetUnlockedMovement(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetUnlockedDuration(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetMusicalTones(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetRemoteConnectStart(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetRemoteConnectEnd(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetRemoteConnectDow(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetMotorSpeed(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetModemType(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetVolume(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetGpsOffBatteryPercent(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetAssistNow(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetPeriodAInterval(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetPeriodBInterval(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetPeriodAStart(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetPeriodBStart(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetSleepBattery(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetAutolock(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_SetGeoblock(setting: Swift.String) -> Swift.Bool
  @objc public func doAction_GetActuations() -> Swift.Bool
  @objc public func doAction_deleteAllBonds(callback: ((_ ret: Swift.Bool) -> (Swift.Bool))! = nil) -> Swift.Bool
  @objc public func doAction_stop() -> Swift.Bool
  @objc public func doAction_siren() -> Swift.Bool
  @objc public func doAction_stopSiren() -> Swift.Bool
  @objc public func doAction_activate() -> Swift.Bool
  @objc public func emptyEncryptedSettingsQueue()
  @objc public func processEncryptionSettingsQueue()
  @objc public func linka_delegate_instance() -> Swift.AnyObject
  @objc public func onBLEPoweredOn()
  @objc public func onBLEPoweredOff()
  @objc public func onConnectToPeripheral(peripheral: CoreBluetooth.CBPeripheral)
  @objc public func onDisconnectToPeripheral(peripheral: CoreBluetooth.CBPeripheral, error: Foundation.NSError?)
  @objc public func onFailToConnectPeripheral(peripheral: CoreBluetooth.CBPeripheral, error: Foundation.NSError?)
  @objc public func onRefreshPeripheralObject(peripheral: CoreBluetooth.CBPeripheral, RSSI: Foundation.NSNumber!, error: Foundation.NSError?)
  @objc public func onRefreshPeripheralServices(peripheral: CoreBluetooth.CBPeripheral)
  @objc public func onCreateNotificationForPeripheralCharacteristic(peripheral: CoreBluetooth.CBPeripheral, characteristic: CoreBluetooth.CBCharacteristic, isConnected: Swift.Bool)
  @objc public func onRefreshPeripheralCharacteristic(peripheral: CoreBluetooth.CBPeripheral, characteristic: CoreBluetooth.CBCharacteristic)
  @objc deinit
}
@objc public enum UserCommand : Swift.Int, Swift.Codable {
  case lock, unLock, none
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum AudioSetting : Swift.Int {
  case off = 0
  case on = 3
  case siren2 = 4
  case siren3 = 5
  case siren_only = 1
  case tones_only = 2
  case none = -1
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum ErrorOther : Swift.UInt {
  case ERROR_LOCK_FACTORY_RESET = 11
  case ERROR_LOCK_KEY_ISSUE = 12
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
@objc public enum ErrorKeyfobAssign : Swift.Int {
  case ERROR_KEYFOB_INVALID = 21
  case ERROR_KEYFOB_INTERNET = 23
  case ERROR_KEYFOB_NOT_CONNECTED = 24
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public protocol LockConnectionServiceDelegate {
  @objc func onPairingUp()
  @objc func onPairingSuccess()
  @objc func onScanFound()
  @objc func onConnected()
  @objc func onBatteryPercent(batteryPercent: Swift.Int)
  @objc func onUnlockStarted()
  @objc func onLockStarted()
  @objc func onLock()
  @objc func onUnlock()
  @objc func errorInternetOff()
  @objc func errorBluetoothOff()
  @objc func errorAppNotInForeground()
  @objc func errorInvalidAccessToken()
  @objc func errorMacAddress(errorMsg: Swift.String)
  @objc func errorConnectionTimeout()
  @objc func errorScanningTimeout()
  @objc func errorLockMoving(tryAgainCompletion: @escaping (Swift.Bool) -> Swift.Void)
  @objc func errorLockStall(tryAgainCompletion: @escaping (Swift.Bool) -> Swift.Void)
  @objc func errorLockJam()
  @objc func errorUnexpectedDisconnect()
  @objc func errorLockingTimeout(tryAgainCompletion: @escaping (Swift.Bool) -> Swift.Void)
  @objc func errorUnlockingTimeout(tryAgainCompletion: @escaping (Swift.Bool) -> Swift.Void)
  @objc optional func errorOther(code: LinkaAPIKit.ErrorOther)
  @objc func onQueryLocked(completionHandler: @escaping (Swift.Bool) -> Swift.Void)
  @objc func onQueryUnlocked(completionHandler: @escaping (Swift.Bool) -> Swift.Void)
}
@objc public protocol LockStatusDelegate {
  @objc optional func onLockStatusPacket(statusPacket: LinkaAPIKit.LockStatusPacket)
  @objc optional func onReadSettingUnlockedSleep(sleep_time_seconds: Swift.UInt)
  @objc optional func onReadSettingLockedSleep(sleep_time_seconds: Swift.UInt)
  @objc optional func onReadSettingAudio(audio: Swift.UInt)
  @objc optional func onReadSettingPac(pac: Swift.UInt)
  @objc optional func onReadSettingKeyfob(keyfobId: Swift.String)
  @objc optional func onReadAirplaneMode(enabled: Swift.Bool)
}
@objc public protocol FactoryResetDelegate {
  @objc func onFactoryResetComplete()
  @objc func onFactoryResetError(errorCode: Swift.Int)
}
@objc public protocol KeyfobAssignDelegate {
  @objc func onKeyfobAssignComplete()
  @objc func onKeyfobAssignError(errorCode: LinkaAPIKit.ErrorKeyfobAssign)
}
@objc @_inheritsConvenienceInitializers @objcMembers public class LockConnectionService : ObjectiveC.NSObject, LinkaAPIKit.LinkaBLECentralManagerDiscoverDelegate {
  @objc public static let FACTORY_RESET_SETTING: Swift.Int
  @objc public static let FACTORY_RESET_SETTING_DEFAULT_VALUE: Swift.Int
  @objc public static let FACTORY_RESET_SETTING_VALID_VALUE: Swift.Int
  @objc public var lockController: LinkaAPIKit.LockController?
  @objc public var timeoutInterval: Swift.Double
  @objc public static let sharedInstance: LinkaAPIKit.LockConnectionService
  @objc public static var lockInfoPacket: LinkaAPIKit.LockInfoPacket!
  @objc public static var lockContextPacket: LinkaAPIKit.LockContextPacket!
  @objc public var command: LinkaAPIKit.UserCommand
  @objc public var lockLocked: Swift.Bool
  @objc public var lockUnlocked: Swift.Bool
  @objc public var hasFoundDevice: Swift.Bool
  @objc public var alreadyHasLockController: Swift.Bool
  @objc public var DisableAutomaticDisconnect: Swift.Bool
  @objc public var write_setting_unlocked_sleep: Swift.Int
  @objc public var write_setting_locked_sleep: Swift.Int
  @objc public var write_setting_pac: Swift.Int
  @objc public var write_setting_audio: LinkaAPIKit.AudioSetting
  public var linka: LinkaAPIKit.Linka
  @objc public func setWrite_setting_audio(write_setting_audio: Swift.Int)
  @objc public func setWrite_airplane_mode(enabled: Swift.Bool)
  @objc public func doRead_setting_audio()
  @objc public func doRead_airplane_mode()
  @objc public func doRead_setting_keyfob()
  @objc public func doRead_setting_unlock_sleep()
  @objc public func doRead_setting_lock_sleep()
  @objc public func doRead_setting_pac()
  @objc public func setWrite_setting_unlocked_sleep(write_setting_unlocked_sleep: Swift.Int)
  @objc public func setWrite_setting_locked_sleep(write_setting_locked_sleep: Swift.Int)
  @objc public func setWrite_setting_pac(write_setting_pac: Swift.Int)
  @objc public func intialize()
  public class func tryDeclareOwnerShip(_ p: LinkaAPIKit.DiscoveredPeripherals, completion: @escaping ((_ status: Swift.String, _ isValid: Swift.Bool) -> Swift.Void))
  @objc public func doLockWithNumber(lockNum: Swift.String, delegate: LinkaAPIKit.LockConnectionServiceDelegate? = nil) -> Swift.Bool
  @objc public func doUnlockWithNumber(lockNum: Swift.String, delegate: LinkaAPIKit.LockConnectionServiceDelegate? = nil) -> Swift.Bool
  @objc public func doQueryWithNumber(lockNum: Swift.String, delegate: LinkaAPIKit.LockConnectionServiceDelegate? = nil) -> Swift.Bool
  @objc public func checkIsConnected() -> Swift.Bool
  @objc public func doLock(macAddress: Swift.String, delegate: LinkaAPIKit.LockConnectionServiceDelegate? = nil) -> Swift.Bool
  @objc public func doUnLock(macAddress: Swift.String, delegate: LinkaAPIKit.LockConnectionServiceDelegate? = nil) -> Swift.Bool
  @objc public func setLockStatusDelegate(delegate: LinkaAPIKit.LockStatusDelegate)
  @objc public func factoryResetDevice(delegate: LinkaAPIKit.FactoryResetDelegate)
  @objc public func assignKeyfob(keyfob_qr: Swift.String, delegate: LinkaAPIKit.KeyfobAssignDelegate)
  @objc public func unassignKeyfob() -> Swift.Bool
  @objc public func tryAgainUnlock()
  @objc public func doSleep()
  @objc public func doSiren()
  @objc public func tryAgainLock()
  @objc public func isCharging() -> Swift.Bool
  @objc public func isTether() -> Swift.Bool
  @objc public func doQuery(macAddress: Swift.String, delegate: LinkaAPIKit.LockConnectionServiceDelegate? = nil) -> Swift.Bool
  @objc public func linka_discover_delegate_instance() -> Swift.AnyObject
  public func onDiscoverNewPeripheral(discoveredPeripheral: LinkaAPIKit.DiscoveredPeripherals)
  @objc public func disconnectWithExistingController()
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers @objcMembers public class DiscoveredPeripherals {
  @objc public var peripheral: CoreBluetooth.CBPeripheral!
  @objc public var advertisementData: [Swift.String : Swift.AnyObject]
  @objc public var RSSI: Foundation.NSNumber!
  @objc public var lockAd: LinkaAPIKit.LockAdV1!
  @objc public func getName() -> Swift.String
  @objc deinit
}
public protocol LinkaBLECentralManagerDiscoverDelegate : AnyObject {
  func linka_discover_delegate_instance() -> Swift.AnyObject
  func onDiscoverNewPeripheral(discoveredPeripheral: LinkaAPIKit.DiscoveredPeripherals)
}
public protocol LinkaBLECentralManagerDelegate : AnyObject {
  func linka_delegate_instance() -> Swift.AnyObject
  func onBLEPoweredOn()
  func onBLEPoweredOff()
  func onConnectToPeripheral(peripheral: CoreBluetooth.CBPeripheral)
  func onDisconnectToPeripheral(peripheral: CoreBluetooth.CBPeripheral, error: Foundation.NSError?)
  func onFailToConnectPeripheral(peripheral: CoreBluetooth.CBPeripheral, error: Foundation.NSError?)
  func onRefreshPeripheralObject(peripheral: CoreBluetooth.CBPeripheral, RSSI: Foundation.NSNumber!, error: Foundation.NSError?)
  func onRefreshPeripheralServices(peripheral: CoreBluetooth.CBPeripheral)
  func onCreateNotificationForPeripheralCharacteristic(peripheral: CoreBluetooth.CBPeripheral, characteristic: CoreBluetooth.CBCharacteristic, isConnected: Swift.Bool)
  func onRefreshPeripheralCharacteristic(peripheral: CoreBluetooth.CBPeripheral, characteristic: CoreBluetooth.CBCharacteristic)
}
@objc @_inheritsConvenienceInitializers public class LinkaBLECentralManager : ObjectiveC.NSObject, CoreBluetooth.CBCentralManagerDelegate, CoreBluetooth.CBPeripheralDelegate {
  public func migrateDatabase()
  public class func sharedInstance() -> LinkaAPIKit.LinkaBLECentralManager
  public class func newInstance() -> LinkaAPIKit.LinkaBLECentralManager
  public var showDebugLog: Swift.Bool
  public var centralManager: CoreBluetooth.CBCentralManager!
  public var isPoweredOn: Swift.Bool
  public var scannedPeripherals: [LinkaAPIKit.DiscoveredPeripherals]
  public var delegates: [LinkaAPIKit.LinkaBLECentralManagerDelegate]
  public var discover_delegates: [LinkaAPIKit.LinkaBLECentralManagerDiscoverDelegate]
  public func addDelegate(delegate: LinkaAPIKit.LinkaBLECentralManagerDelegate)
  public func removeDelegate(delegate: LinkaAPIKit.LinkaBLECentralManagerDelegate)
  public func addDiscoverDelegate(delegate: LinkaAPIKit.LinkaBLECentralManagerDiscoverDelegate)
  public func removeDiscoverDelegate(delegate: LinkaAPIKit.LinkaBLECentralManagerDiscoverDelegate)
  public func isBluetoothAuthorized() -> Swift.Bool
  public func retrieveFromUUIDs(UUIDS: [Foundation.NSUUID]) -> [CoreBluetooth.CBPeripheral]
  public func retrieve() -> [CoreBluetooth.CBPeripheral]
  public func retrieveConnectedPeripherals() -> [CoreBluetooth.CBPeripheral]
  public func startScan()
  public func stopScan()
  public func connect(peripheral: CoreBluetooth.CBPeripheral)
  public func disconnect(peripheral: CoreBluetooth.CBPeripheral)
  public func discoverServices(peripheral: CoreBluetooth.CBPeripheral)
  public func discoverAllCharacteristics(peripheral: CoreBluetooth.CBPeripheral)
  public func readRSSI(peripheral: CoreBluetooth.CBPeripheral)
  @objc public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didWriteValueFor characteristic: CoreBluetooth.CBCharacteristic, error: Swift.Error?)
  @objc public func centralManager(_ central: CoreBluetooth.CBCentralManager, willRestoreState dict: [Swift.String : Any])
  @objc public func centralManagerDidUpdateState(_ central: CoreBluetooth.CBCentralManager)
  @objc public func centralManager(_ central: CoreBluetooth.CBCentralManager, didDiscover peripheral: CoreBluetooth.CBPeripheral, advertisementData: [Swift.String : Any], rssi RSSI: Foundation.NSNumber)
  @objc public func centralManager(_ central: CoreBluetooth.CBCentralManager, didConnect peripheral: CoreBluetooth.CBPeripheral)
  @objc public func centralManager(_ central: CoreBluetooth.CBCentralManager, didDisconnectPeripheral peripheral: CoreBluetooth.CBPeripheral, error: Swift.Error?)
  @objc public func centralManager(_ central: CoreBluetooth.CBCentralManager, didFailToConnect peripheral: CoreBluetooth.CBPeripheral, error: Swift.Error?)
  @objc public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didDiscoverServices error: Swift.Error?)
  @objc public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didDiscoverCharacteristicsFor service: CoreBluetooth.CBService, error: Swift.Error?)
  @objc public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didDiscoverDescriptorsFor characteristic: CoreBluetooth.CBCharacteristic, error: Swift.Error?)
  @objc public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didUpdateNotificationStateFor characteristic: CoreBluetooth.CBCharacteristic, error: Swift.Error?)
  @objc public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didUpdateValueFor characteristic: CoreBluetooth.CBCharacteristic, error: Swift.Error?)
  @objc public func peripheral(_ peripheral: CoreBluetooth.CBPeripheral, didReadRSSI RSSI: Foundation.NSNumber, error: Swift.Error?)
  @objc override dynamic public init()
  @objc deinit
}
@_inheritsConvenienceInitializers @objcMembers public class LinkaKeyfobGetResponseMapping : LinkaAPIKit.LinkaAPIResponse {
  public var data: LinkaAPIKit.LinkaKeyfobGetResponseDataMapping?
  override public func mapping(map: LinkaAPIKit.Map)
  required public init?(map: LinkaAPIKit.Map)
  @objc deinit
}
@objcMembers public class LinkaKeyfobGetResponseDataMapping : LinkaAPIKit.Mappable {
  @objc public var _id: Swift.String?
  @objc public var mac_address: Swift.String?
  @objc public var uuid: Swift.String?
  @objc public var minor: Swift.String?
  @objc public var major: Swift.String?
  required public init?(map: LinkaAPIKit.Map)
  public func mapping(map: LinkaAPIKit.Map)
  @objc deinit
}
final public class MD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension LinkaAPIKit.MD5 : LinkaAPIKit.Updatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
public protocol LinkaAPIProtocol : AnyObject {
  func Linka_locationManager() -> CoreLocation.CLLocationManager!
  func LinkaMerchantAPI_getAPIKey() -> Swift.String!
  func LinkaMerchantAPI_getSecretKey() -> Swift.String!
  func LinkaMerchantAPI_UserEmail() -> Swift.String?
  func LinkaMerchantAPI_getIsButtonUsed() -> Swift.Bool
}
extension LinkaAPIKit.LinkaAPIProtocol {
  public func LinkaMerchantAPI_UserEmail() -> Swift.String?
}
infix operator <- : DefaultPrecedence
infix operator >>> : DefaultPrecedence
public func <- <T>(left: inout T, right: LinkaAPIKit.Map)
public func >>> <T>(left: T, right: LinkaAPIKit.Map)
public func <- <T>(left: inout T?, right: LinkaAPIKit.Map)
public func >>> <T>(left: T?, right: LinkaAPIKit.Map)
public func <- <T>(left: inout T, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func >>> <T>(left: T, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func <- <T>(left: inout T?, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func >>> <T>(left: T?, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, T>, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, T>, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, T>?, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, T>?, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, [T]>, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, [T]>, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func <- <T>(left: inout Swift.Dictionary<Swift.String, [T]>?, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func >>> <T>(left: Swift.Dictionary<Swift.String, [T]>?, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func <- <T>(left: inout Swift.Array<T>, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func >>> <T>(left: Swift.Array<T>, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func <- <T>(left: inout Swift.Array<T>?, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func >>> <T>(left: Swift.Array<T>?, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func <- <T>(left: inout Swift.Array<Swift.Array<T>>, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func >>> <T>(left: Swift.Array<Swift.Array<T>>, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func <- <T>(left: inout Swift.Array<Swift.Array<T>>?, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func >>> <T>(left: Swift.Array<Swift.Array<T>>?, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable
public func <- <T>(left: inout Swift.Set<T>, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable, T : Swift.Hashable
public func >>> <T>(left: Swift.Set<T>, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable, T : Swift.Hashable
public func <- <T>(left: inout Swift.Set<T>?, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable, T : Swift.Hashable
public func >>> <T>(left: Swift.Set<T>?, right: LinkaAPIKit.Map) where T : LinkaAPIKit.BaseMappable, T : Swift.Hashable
@_specialize(exported: false, kind: full, where T == Swift.Int)
@_specialize(exported: false, kind: full, where T == Swift.UInt)
@_specialize(exported: false, kind: full, where T == Swift.UInt8)
@_specialize(exported: false, kind: full, where T == Swift.UInt16)
@_specialize(exported: false, kind: full, where T == Swift.UInt32)
@_specialize(exported: false, kind: full, where T == Swift.UInt64)
@inlinable internal func arrayOfBytes<T>(value: T, length totalBytes: Swift.Int = MemoryLayout<T>.size) -> Swift.Array<Swift.UInt8> where T : Swift.FixedWidthInteger {
  let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
  valuePointer.pointee = value

  let bytesPointer = UnsafeMutablePointer<UInt8>(OpaquePointer(valuePointer))
  var bytes = Array<UInt8>(repeating: 0, count: totalBytes)
  for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
    bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
  }

  valuePointer.deinitialize(count: 1)
  valuePointer.deallocate()

  return bytes
}
extension Swift.String {
  @inlinable public var bytes: Swift.Array<Swift.UInt8> {
    get {
    data(using: String.Encoding.utf8, allowLossyConversion: true)?.bytes ?? Array(utf8)
  }
  }
  @inlinable public func md5() -> Swift.String {
    self.bytes.md5().toHexString()
  }
  @inlinable public func sha1() -> Swift.String {
    self.bytes.sha1().toHexString()
  }
  @inlinable public func sha224() -> Swift.String {
    self.bytes.sha224().toHexString()
  }
  @inlinable public func sha256() -> Swift.String {
    self.bytes.sha256().toHexString()
  }
  @inlinable public func sha384() -> Swift.String {
    self.bytes.sha384().toHexString()
  }
  @inlinable public func sha512() -> Swift.String {
    self.bytes.sha512().toHexString()
  }
  @inlinable public func sha3(_ variant: LinkaAPIKit.SHA3.Variant) -> Swift.String {
    self.bytes.sha3(variant).toHexString()
  }
  @inlinable public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytes.crc32c(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc16(seed: Swift.UInt16? = nil) -> Swift.String {
    self.bytes.crc16(seed: seed).bytes().toHexString()
  }
  @inlinable public func encrypt(cipher: LinkaAPIKit.Cipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toHexString()
  }
  @inlinable public func encryptToBase64(cipher: LinkaAPIKit.Cipher) throws -> Swift.String {
    try self.bytes.encrypt(cipher: cipher).toBase64()
  }
  @inlinable public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : LinkaAPIKit.Authenticator {
    try self.bytes.authenticate(with: authenticator).toHexString()
  }
}
@objc @_inheritsConvenienceInitializers public class ConfigurationSettings : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
public protocol CipherModeWorker {
  var cipherOperation: LinkaAPIKit.CipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  @inlinable mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @inlinable mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol BlockModeWorker : LinkaAPIKit.CipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol CounterModeWorker : LinkaAPIKit.CipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol SeekableModeWorker : LinkaAPIKit.CipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol StreamModeWorker : LinkaAPIKit.CipherModeWorker {
}
public protocol FinalizingEncryptModeWorker : LinkaAPIKit.CipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol FinalizingDecryptModeWorker : LinkaAPIKit.CipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol Updatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension LinkaAPIKit.Updatable {
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: isLast)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes.slice, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.update(withBytes: bytes.slice, isLast: isLast, output: output)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.finish(withBytes: bytes.slice)
  }
  @inlinable public mutating func finish() throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: [], isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: true)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: bytes.slice, output: output)
  }
  @inlinable public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: [], output: output)
  }
}
final public class Scrypt {
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, dkLen: Swift.Int, N: Swift.Int, r: Swift.Int, p: Swift.Int) throws
  final public func calculate() throws -> [Swift.UInt8]
  @objc deinit
}
final public class SHA1 {
  @usableFromInline
  internal static let digestLength: Swift.Int
  @usableFromInline
  internal static let blockSize: Swift.Int
  @usableFromInline
  internal static let hashInitialValue: Swift.ContiguousArray<Swift.UInt32>
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash: Swift.ContiguousArray<Swift.UInt32>
  public init()
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.ContiguousArray<Swift.UInt32>)
  @objc deinit
}
extension LinkaAPIKit.SHA1 : LinkaAPIKit.Updatable {
  @discardableResult
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: 64 / 8) // A 64-bit representation of b

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: SHA1.blockSize, allowance: 64 / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: SHA1.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= SHA1.blockSize {
        self.process(block: chunk, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: SHA1.digestLength)
    var pos = 0
    for idx in 0..<self.accumulatedHash.count {
      let h = self.accumulatedHash[idx]
      result[pos + 0] = UInt8((h >> 24) & 0xff)
      result[pos + 1] = UInt8((h >> 16) & 0xff)
      result[pos + 2] = UInt8((h >> 8) & 0xff)
      result[pos + 3] = UInt8(h & 0xff)
      pos += 4
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = SHA1.hashInitialValue
    }

    return result
  }
}
public struct ECB : LinkaAPIKit.BlockMode {
  public let options: LinkaAPIKit.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping LinkaAPIKit.CipherOperationOnBlock, encryptionOperation: @escaping LinkaAPIKit.CipherOperationOnBlock) throws -> LinkaAPIKit.CipherModeWorker
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: LinkaAPIKit.CipherError, b: LinkaAPIKit.CipherError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Cipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension LinkaAPIKit.Cipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public struct CRC16 {
  public typealias CRCType = Swift.UInt16
  public var crc: LinkaAPIKit.CRC16.CRCType! {
    get
  }
  public init()
  public static func accumulate(_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>, crc: LinkaAPIKit.CRC16.CRCType = 0xFFFF) -> LinkaAPIKit.CRC16.CRCType
  public mutating func accumulate(_ buffer: Swift.UnsafeBufferPointer<Swift.UInt8>)
}
extension LinkaAPIKit.CRC16 {
  public mutating func accumulate(_ bytes: [Swift.UInt8])
  public mutating func accumulate(_ string: Swift.String)
}
extension LinkaAPIKit.Rabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
@objc @_hasMissingDesignatedInitializers public class LockStatusPacket : LinkaAPIKit.LockDataPacket {
  public func GetLockStateRepresentation() -> Swift.String
  public func GetAuthStateRepresentation() -> Swift.String
  public func GetTransitionReason() -> LinkaAPIKit.Byte
  public func GetTransitionReasonLocalized() -> Swift.String
  public func GetTransitionReasonPrev() -> LinkaAPIKit.Byte
  public func GetTransitionReasonPrevLocalized() -> Swift.String
  public func GetBatteryVoltage() -> Swift.Double
  public func GetBatteryPercent() -> LinkaAPIKit.Byte
  public func GetBatteryPercentRaw() -> Swift.Double
  public func GetStateFlags() -> Swift.UInt
  public func GetStateFlagsRepresentation() -> Swift.String
  public func GetStatusFlags() -> Swift.UInt
  public func GetCurrent_mA() -> LinkaAPIKit.Byte
  public func GetLockState() -> LinkaAPIKit.LockState
  public func GetTamperState() -> Swift.UInt
  public func GetHvBoard() -> Swift.UInt
  public func GetAuthState() -> LinkaAPIKit.AuthState
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers public class LockSettingPacket : LinkaAPIKit.LockDataPacket {
  public static let VLSO_SETTING_LOCK_ID: Swift.Int
  public static let VLSO_SETTING_LOCK_PAC_CODE: Swift.Int
  public static let VLSO_SETTING_LOCK_ACTUATIONS: Swift.Int
  public static let VLSO_SETTING_LOCK_ERRORS: Swift.Int
  public static let VLSO_SETTING_LOCK_MODE: Swift.Int
  public static let VLSO_SETTING_STALL_MA: Swift.Int
  public static let VLSO_SETTING_ACCEL_LOCK_TH: Swift.Int
  public static let VLSO_SETTING_ALARM_DELAY_S: Swift.Int
  public static let VLSO_SETTING_ALARM_TIMEOUT_S: Swift.Int
  public static let VLSO_SETTING_LAST_STATE: Swift.Int
  public static let VLSO_SETTING_BUMP_TH_MG: Swift.Int
  public static let VLSO_SETTING_RSSI_UNLOCK_MIN: Swift.Int
  public static let VLSO_SETTING_AUDIO: Swift.Int
  public static let VLSO_SETTING_PULSE_TH_MG: Swift.Int
  public static let VLSO_SETTING_JOSTLE_100MS: Swift.Int
  public static let VLSO_SETTING_LOCKED_SLEEP_S: Swift.Int
  public static let VLSO_SETTING_MK1_0: Swift.Int
  public static let VLSO_SETTING_MK1_1: Swift.Int
  public static let VLSO_SETTING_MK2_0: Swift.Int
  public static let VLSO_SETTING_MK2_1: Swift.Int
  public static let VLSO_SETTING_ROLL_ALRM_DEG: Swift.Int
  public static let VLSO_SETTING_PITCH_ALRM_DEG: Swift.Int
  public static let VLSO_SETTING_BL_ENB_FLAGS: Swift.Int
  public static let VLSO_SETTING_ALARM_DURATION_S: Swift.Int
  public static let VLSO_SETTING_ACT_BLOCK_LOCK_S: Swift.Int
  public static let VLSO_SETTING_SIREN_BLOCK_ACT: Swift.Int
  public static let VLSO_SET_ACC_POST_LOCK_DELAY_S: Swift.Int
  public static let VLSO_SET_STALL_IGNORE_TIME_100MS: Swift.Int
  public static let VLSO_SET_MAX_UNLOCKING_TIME_250MS: Swift.Int
  public static let VLSO_SET_LOW_TEMP_C: Swift.Int
  public static let VLSO_SET_TEMP_OFS_C: Swift.Int
  public static let VLSO_SET_STALL_DELAY_100MS: Swift.Int
  public static let VLSO_SET_BONDING_REQUIRED: Swift.Int
  public static let VLSO_SETTING_UNLOCKED_BUMP_TH_MG: Swift.Int
  public static let VLSO_SETTING_MIN_BATT_PCT_LOCK: Swift.Int
  public static let VLSO_SETTING_MIN_BATT_PCT_SLEEP: Swift.Int
  public static let VLSO_SETTING_UNLOCKED_UNCONN_SLEEP_S: Swift.Int
  public static let VLSO_SETTING_SLOW_DELAY_100MS: Swift.Int
  public static let VLSO_SETTING_MOTOR_SPD_INITIAL: Swift.Int
  public static let VLSO_SETTING_MOTOR_SPD_SLOW: Swift.Int
  public static let VLSO_SETTING_MOTOR_LOCK_CODE: Swift.Int
  public static let VLSO_SETTING_ALLOW_UNCONN_LOCK: Swift.Int
  public static let VLSO_SETTING_ALARM_FREQ_HZ: Swift.Int
  public static let VLSO_SETTING_ALARM_DUTY_PCT: Swift.Int
  public static let VLSO_SETTING_BEEP_FREQ_HZ: Swift.Int
  public static let VLSO_SETTING_BEEP_DUTY_PCT: Swift.Int
  public static let VLSO_SETTING_STALL_RETRACT: Swift.Int
  public static let VLSO_SETTING_BLE_LOG: Swift.Int
  public static let VLSO_SETTING_MODEM_TYPE: Swift.Int
  public static let VLSO_SETTING_GNSS_ACCURACY: Swift.Int
  public static let VLSO_SETTING_GNSS_TIMEOUT: Swift.Int
  public static let VLSO_SETTING_GNSS_INTERVAL_A: Swift.Int
  public static let VLSO_SETTING_GNSS_INTERVAL_B: Swift.Int
  public static let VLSO_SETTING_GNSS_INTERVAL_THEFT: Swift.Int
  public static let VLSO_SETTING_GNSS_THEFT_DURATION: Swift.Int
  public static let VLSO_SETTING_RESET_TIMES: Swift.Int
  public static let VLSO_SETTING_GNSS_MODE: Swift.Int
  public static let VLSO_SETTING_GNSS_FILTER: Swift.Int
  public static let VLSO_SETTING_IP_ADDR: Swift.Int
  public static let VLSO_SETTING_GNSS_UNLOCK_DURATION: Swift.Int
  public static let VLSO_SETTING_STATE_CHANGE_PING: Swift.Int
  public static let VLSO_SETTING_PWR_BUTTON_PING: Swift.Int
  public static let VLSO_SETTING_GNSS_INTERVAL_UNLOCK: Swift.Int
  public static let VLSO_SETTING_GNSS_INTERVAL_LOCK: Swift.Int
  public static let VLSO_SETTING_USER_ID: Swift.Int
  public static let VLSO_SETTING_LOOP_CONTROL: Swift.Int
  public static let VLSO_SETTING_RESET_TIMER_S: Swift.Int
  public static let VLSO_SETTING_FULL_GPS: Swift.Int
  public static let VLSO_SETTING_MIN_BATT_PCT_UNLOCK: Swift.Int
  public static let VLSO_SETTING_BATT_PCT_GPS_OFF: Swift.Int
  public static let VLSO_SETTING_ASSIST_NOW: Swift.Int
  public static let VLSO_SETTING_PERIOD_A_START: Swift.Int
  public static let VLSO_SETTING_PERIOD_B_START: Swift.Int
  public static let VLSO_SETTING_LOW_BATT_SLEEP: Swift.Int
  public static let VLSO_SET_MAX_LOCKING_TIME_250MS: Swift.Int
  public static let VLSO_SETTING_NETWORK_CODE: Swift.Int
  public static let VLSO_SETTING_OPERATOR_MODE: Swift.Int
  public static let VLSO_SETTING_REMOTE_COMMANDS: Swift.Int
  public static let VLSO_SETTING_OTA_FIRMWARE: Swift.Int
  public static let VLSO_SETTING_GEOBLOCK: Swift.Int
  public static let VLSO_SETTING_CHARGING: Swift.Int
  public static let VLSO_SETTING_CHAIN_STATE: Swift.Int
  public static let VLSO_SETTING_AT_ERRORS: Swift.Int
  public static let VLSO_SETTING_KEYFOB_MAC: Swift.Int
  public static let VLSO_SETTING_KEYFOB_UUID_0: Swift.Int
  public static let VLSO_SETTING_KEYFOB_UUID_1: Swift.Int
  public static let VLSO_SETTING_KEYFOB_MAJOR: Swift.Int
  public static let VLSO_SETTING_KEYFOB_MINOR: Swift.Int
  public static let VLSO_SETTING_AUTO_LOCK: Swift.Int
  public static let VLSO_SETTING_RECOVERY_MODE: Swift.Int
  public static let VLSO_SETTING_POWER_MODE: Swift.Int
  public static let VLSO_SETTING_TETHER: Swift.Int
  public static let VLSO_SETTING_UNLOCK_CELL: Swift.Int
  public static let VLSO_SETTING_MUSICAL_TONES: Swift.Int
  public static let VLSO_SETTING_REMOTE_START: Swift.Int
  public static let VLSO_SETTING_REMOTE_END: Swift.Int
  public static let VLSO_SETTING_REMOTE_DOW: Swift.Int
  public static let VLSO_SETTING_MAX: Swift.Int
  public func settingIndex() -> Swift.UInt
  public func settingLong() -> Swift.UInt64
  public func value() -> Swift.UInt
  public init(command: LinkaAPIKit.Byte, settingIndex: LinkaAPIKit.Byte, settingValue: Swift.UInt, settingValue2: Swift.UInt)
  public init(command: LinkaAPIKit.Byte, settingIndex: LinkaAPIKit.Byte, longValue: Swift.UInt64)
  public init(command: LinkaAPIKit.Byte, settingIndex: LinkaAPIKit.Byte, data: [LinkaAPIKit.Byte])
  @objc deinit
}
open class URLTransform : LinkaAPIKit.TransformType {
  public typealias Object = Foundation.URL
  public typealias JSON = Swift.String
  public init(shouldEncodeURLString: Swift.Bool = false, allowedCharacterSet: Foundation.CharacterSet = .urlQueryAllowed)
  open func transformFromJSON(_ value: Any?) -> Foundation.URL?
  open func transformToJSON(_ value: Foundation.URL?) -> Swift.String?
  @objc deinit
}
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: LinkaAPIKit.Blowfish.Error, b: LinkaAPIKit.Blowfish.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: LinkaAPIKit.BlockMode = CBC(iv: Array<UInt8>(repeating: 0, count: Blowfish.blockSize)), padding: LinkaAPIKit.Padding) throws
  @objc deinit
}
extension LinkaAPIKit.Blowfish : LinkaAPIKit.Cipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
public class CMAC : LinkaAPIKit.Authenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: LinkaAPIKit.CMAC.Error, b: LinkaAPIKit.CMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>, cipher: LinkaAPIKit.Cipher) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension LinkaAPIKit.Blowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: LinkaAPIKit.Padding = .pkcs7) throws
}
final public class SHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var accumulatedHash: Swift.Array<Swift.UInt64>
  public enum Variant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: LinkaAPIKit.SHA3.Variant, b: LinkaAPIKit.SHA3.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(variant: LinkaAPIKit.SHA3.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt64>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @objc deinit
}
extension LinkaAPIKit.SHA3 : LinkaAPIKit.Updatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      // Add padding
      let markByteIndex = self.accumulated.count

      // We need to always pad the input. Even if the input is a multiple of blockSize.
      let r = self.blockSize * 8
      let q = (r / 8) - (accumulated.count % (r / 8))
      self.accumulated += Array<UInt8>(repeating: 0, count: q)

      self.accumulated[markByteIndex] |= self.markByte
      self.accumulated[self.accumulated.count - 1] |= 0x80
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        self.process(block: chunk.toUInt64Array().slice, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)

    // TODO: verify performance, reduce vs for..in
    let result = self.accumulatedHash.reduce(into: Array<UInt8>()) { (result, value) in
      result += value.bigEndian.bytes()
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = Array<UInt64>(repeating: 0, count: self.digestLength)
    }

    return Array(result[0..<self.digestLength])
  }
}
public struct BlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  @usableFromInline
  internal static let none: LinkaAPIKit.BlockModeOption
  @usableFromInline
  internal static let initializationVectorRequired: LinkaAPIKit.BlockModeOption
  @usableFromInline
  internal static let paddingRequired: LinkaAPIKit.BlockModeOption
  @usableFromInline
  internal static let useEncryptToDecrypt: LinkaAPIKit.BlockModeOption
  public typealias ArrayLiteralElement = LinkaAPIKit.BlockModeOption
  public typealias Element = LinkaAPIKit.BlockModeOption
  public typealias RawValue = Swift.Int
}
public protocol Cryptor {
  mutating func seek(to: Swift.Int) throws
}
public enum LeoMode : Swift.UInt8 {
  case MODE_OFF
  case MODE_THEFT
  case MODE_PERIOD_PING
  case MODE_PERIOD_PING_WAITING_GPS
  case MODE_MANUAL
  case MODE_THEFT_PENDING
  case MODE_SETUP_LTE
  case MODE_STATE_PING
  case MODE_THEFT_WAITING_GPS
  case MODE_UNLOCKED
  case MODE_LOCKED
  case MODE_TURNING_OFF
  case MODE_DONE
  case MODE_STATE_PING_WAITING_GPS
  case MODE_SEND_FINAL_GPS
  case MODE_UNLOCKED_PENDING
  case MODE_LOCKED_PENDING
  case MODE_RESET
  case MODE_FULL_GPS
  case MODE_CAPTURE_GPS
  case MODE_CONFIRM_OFF
  case MODE_CHECK_TIME
  case MODE_SEND_GPS_PING
  case MODE_SEND_GPS_THEFT
  case MODE_CELL_LOCATE
  case MODE_SEND_GPS_CELL_LOCATE
  case MODE_FULL_GPS_PENDING
  case MODE_OTA_UPDATE
  case MODE_REMOTE_COMMAND
  case MODE_REMOTE_COMMAND_PENDING
  case MODE_RESET_PING
  case MODE_POWER_BUTTON_CONNECT
  case MODE_GEOBLOCK
  case MODE_GEOBLOCK_WAITING_GPS
  case MODE_GEOBLOCK_WAIT_COMMAND
  case MODE_REMOTE_COMMAND_CONNECTED
  case MODE_GNSS_TEST
  case MODE_UNLOCK_CELL_CONNECTED
  case MODE_UNLOCK_CELL_SLEEP
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
@_hasMissingDesignatedInitializers @objcMembers public class Linka {
  @objc dynamic public var peripheral: CoreBluetooth.CBPeripheral!
  @objc dynamic public var tamperStatus: Swift.Int
  @objc public var serial_number: Swift.String
  @objc open func getPeripheral() -> CoreBluetooth.CBPeripheral!
  @objc open func getMACAddress() -> Swift.String
  @objc open func getFwVersion() -> Swift.String
  @objc open func isBonded() -> Swift.Bool
  @objc open func getBatteryRemainingRepresentation() -> Swift.String
  @objc open func getName() -> Swift.String
  open class func getName(_ mac_address: Swift.String, peripheral: LinkaAPIKit.DiscoveredPeripherals) -> Swift.String
  open class func makeLinka(_ peripheral: LinkaAPIKit.DiscoveredPeripherals) -> LinkaAPIKit.Linka
  open class func makeLinka(_ macAddress: Swift.String) -> LinkaAPIKit.Linka
  @objc public func updateLocation()
  public func recordLockActivity(lockState: LinkaAPIKit.LockState)
  @objc public func isLeoLock() -> Swift.Bool
  @objc public func isLeo2Lock() -> Swift.Bool
  @objc public func setTamperStatus(status: Swift.Int)
  @objc public func updateRSSI(_ discoverable: Swift.Bool, rssi: Swift.Int) -> Swift.Bool
  @objc deinit
}
final public class OCB : LinkaAPIKit.BlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: LinkaAPIKit.OCB.Mode, b: LinkaAPIKit.OCB.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: LinkaAPIKit.BlockModeOption
  public enum Error : Swift.Error {
    case invalidNonce
    case fail
    public static func == (a: LinkaAPIKit.OCB.Error, b: LinkaAPIKit.OCB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(nonce N: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: LinkaAPIKit.OCB.Mode = .detached)
  @inlinable convenience public init(nonce N: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: LinkaAPIKit.OCB.Mode = .detached) {
    self.init(nonce: N, additionalAuthenticatedData: additionalAuthenticatedData, tagLength: authenticationTag.count, mode: mode)
    self.authenticationTag = authenticationTag
  }
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping LinkaAPIKit.CipherOperationOnBlock, encryptionOperation: @escaping LinkaAPIKit.CipherOperationOnBlock) throws -> LinkaAPIKit.CipherModeWorker
  @objc deinit
}
@_hasMissingDesignatedInitializers open class LocksController {
  public static func initialize()
  @objc deinit
}
public struct CBC : LinkaAPIKit.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: LinkaAPIKit.CBC.Error, b: LinkaAPIKit.CBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: LinkaAPIKit.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping LinkaAPIKit.CipherOperationOnBlock, encryptionOperation: @escaping LinkaAPIKit.CipherOperationOnBlock) throws -> LinkaAPIKit.CipherModeWorker
}
@objc @_hasMissingDesignatedInitializers public class LockContextPacket : LinkaAPIKit.LockDataPacket {
  public func getEncVer() -> Swift.UInt
  public func getVoltage() -> Swift.UInt
  public func getAtMode() -> Swift.UInt
  public func getCounter() -> Swift.Int
  public func updateCounter(newCounter: Swift.Int) -> Swift.Bool
  public func getCRC1() -> Swift.UInt
  public func getCRC2() -> Swift.UInt
  public func isCRC1DefaultMK1() -> Swift.Bool
  public func isCRC2DefaultMK2() -> Swift.Bool
  public func getBondsRemaining() -> Swift.UInt
  public func getCurrentBondIndex() -> Swift.UInt
  public func isBondingRequired() -> Swift.Bool
  public init(data: [LinkaAPIKit.Byte])
  public static func atModeToString(mode: Swift.UInt8) -> Swift.String
  public enum CellState : Swift.UInt8 {
    case CellStateSuspend
    case CellStateOff
    case CellStateConnecting
    case CellStateConnected
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public static func getStringForCellState(state: LinkaAPIKit.LockContextPacket.CellState) -> Swift.String
  public func atModeConnectionStatus() -> LinkaAPIKit.LockContextPacket.CellState
  @objc deinit
}
public struct DictionaryTransform<Key, Value> : LinkaAPIKit.TransformType where Key : Swift.Hashable, Key : Swift.RawRepresentable, Value : LinkaAPIKit.Mappable, Key.RawValue == Swift.String {
  public init()
  public func transformFromJSON(_ value: Any?) -> [Key : Value]?
  public func transformToJSON(_ value: [Key : Value]?) -> Any?
  public typealias JSON = Any
  public typealias Object = Swift.Dictionary<Key, Value>
}
@_inheritsConvenienceInitializers @objcMembers public class LinkaMerchantAPIResponseMapping : LinkaAPIKit.LinkaAPIResponse {
  public var data: LinkaAPIKit.LinkaMerchantAPIResponseDataMapping?
  override public func mapping(map: LinkaAPIKit.Map)
  required public init?(map: LinkaAPIKit.Map)
  @objc deinit
}
@objcMembers public class LinkaMerchantAPIResponseDataMapping : LinkaAPIKit.Mappable {
  required public init?(map: LinkaAPIKit.Map)
  public func mapping(map: LinkaAPIKit.Map)
  @objc deinit
}
extension LinkaAPIKit.ChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
@available(*, renamed: "Digest")
public typealias Hash = LinkaAPIKit.Digest
public struct Digest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: LinkaAPIKit.SHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: LinkaAPIKit.SHA3.Variant) -> Swift.Array<Swift.UInt8>
}
public enum AuthState : Swift.UInt8 {
  case auth_NONE
  case auth_PAIRING
  case auth_COMPLETE
  case auth_ERROR
  case auth_PAIRED
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
@objc @_inheritsConvenienceInitializers @objcMembers public class LinkaMerchantAPIService : ObjectiveC.NSObject {
  @objc public class func saveAccessToken(_ access_token: Swift.String)
  @objc public class func clearAccessToken()
  @objc public class func hasAccessToken() -> Swift.Bool
  @objc public class func getAccessToken() -> Swift.String!
  public class func fetch_access_token(_ completion: @escaping ((_ responseObject: LinkaAPIKit.LinkaMerchantAPIResponseMapping?, _ error: LinkaAPIKit.LinkaAPIResponse?) -> Swift.Void)) -> LinkaAPIKit.Request
  public class func view_merchant(_ completion: @escaping ((_ responseObject: Swift.String?, _ error: LinkaAPIKit.LinkaAPIResponse?) -> Swift.Void)) -> LinkaAPIKit.Request
  public class func test_access_token(_ completion: @escaping ((_ responseObject: Swift.String?, _ error: LinkaAPIKit.LinkaAPIResponse?) -> Swift.Void)) -> LinkaAPIKit.Request
  public class func fetch_all_locks(_ completion: @escaping ((_ responseObject: LinkaAPIKit.LinkaMerchantlockListAPIResponseMapping?, _ error: LinkaAPIKit.LinkaAPIResponse?) -> Swift.Void)) -> LinkaAPIKit.Request
  public class func fetch_lock(_ linka: LinkaAPIKit.Linka, lock_number: Swift.String?, completion: @escaping ((_ responseObject: LinkaAPIKit.LinkaMerchantlockAPIResponseMapping?, _ error: LinkaAPIKit.LinkaAPIResponse?) -> Swift.Void)) -> LinkaAPIKit.Request
  public class func tryDeclareLockOwnership(_ p: LinkaAPIKit.DiscoveredPeripherals, callback: ((_ linka: LinkaAPIKit.Linka?, _ isValid: Swift.Bool, _ showError: Swift.Bool, _ errorCode: Swift.Int) -> Swift.Void)!)
  public class func tryPreparePairingUp(_ macAddress: Swift.String, lock_number: Swift.String?, progressCallback: ((_ isLoading: Swift.Bool, _ state: Swift.Int) -> Swift.Void)!, callback: ((_ linka: LinkaAPIKit.Linka?, _ isValid: Swift.Bool, _ showError: Swift.Bool, _ errorCode: Swift.Int) -> Swift.Void)!, successCallback: ((_ connectManager: LinkaAPIKit.LinkaBLEConnectManager?, _ communicationManager: LinkaAPIKit.LinkaBLECommunicationManager?, _ lockController: LinkaAPIKit.LockController) -> Swift.Void)!)
  @objc public static var lockController: LinkaAPIKit.LockController!
  public class func pairNewLockWithNumber(_ p: LinkaAPIKit.DiscoveredPeripherals, lockNumber: Swift.String, progressCallback: ((_ isLoading: Swift.Bool, _ state: Swift.Int) -> Swift.Void)!, callback: ((_ linka: LinkaAPIKit.Linka?, _ isValid: Swift.Bool, _ showError: Swift.Bool, _ errorCode: Swift.Int) -> Swift.Void)!, successCallback: ((_ connectManager: LinkaAPIKit.LinkaBLEConnectManager?, _ communicationManager: LinkaAPIKit.LinkaBLECommunicationManager?) -> Swift.Void)!)
  public class func tryPreparePairingUp(_ p: LinkaAPIKit.DiscoveredPeripherals, progressCallback: ((_ isLoading: Swift.Bool, _ state: Swift.Int) -> Swift.Void)!, callback: ((_ linka: LinkaAPIKit.Linka?, _ isValid: Swift.Bool, _ showError: Swift.Bool, _ errorCode: Swift.Int) -> Swift.Void)!, successCallback: ((_ connectManager: LinkaAPIKit.LinkaBLEConnectManager?, _ communicationManager: LinkaAPIKit.LinkaBLECommunicationManager?) -> Swift.Void)!)
  @objc open class func makeLocationManager() -> CoreLocation.CLLocationManager!
  @objc override dynamic public init()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class LockController : ObjectiveC.NSObject, UIKit.UIAlertViewDelegate {
  @_Concurrency.MainActor(unsafe) public static var operatorAppCode: Swift.String
  @_Concurrency.MainActor(unsafe) public var AUTHENTICATION_SECONDS_COMMAND: Swift.Int
  @_Concurrency.MainActor(unsafe) public var authenticationCountSeconds: Swift.Int
  @_Concurrency.MainActor(unsafe) public static var PostLockDelaySeconds: Swift.Double
  @_Concurrency.MainActor(unsafe) public var linka: LinkaAPIKit.Linka!
  @_Concurrency.MainActor(unsafe) public var connectManager: LinkaAPIKit.LinkaBLEConnectManager!
  @_Concurrency.MainActor(unsafe) public var communicationManager: LinkaAPIKit.LinkaBLECommunicationManager!
  @_Concurrency.MainActor(unsafe) public func doDisconnectDevice()
  @_Concurrency.MainActor(unsafe) public func deinitialize()
  @objc deinit
}
public func <- <T>(left: inout T, right: LinkaAPIKit.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: T, right: LinkaAPIKit.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout T?, right: LinkaAPIKit.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: T?, right: LinkaAPIKit.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [T], right: LinkaAPIKit.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [T], right: LinkaAPIKit.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [T]?, right: LinkaAPIKit.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [T]?, right: LinkaAPIKit.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [Swift.String : T], right: LinkaAPIKit.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [Swift.String : T], right: LinkaAPIKit.Map) where T : Swift.RawRepresentable
public func <- <T>(left: inout [Swift.String : T]?, right: LinkaAPIKit.Map) where T : Swift.RawRepresentable
public func >>> <T>(left: [Swift.String : T]?, right: LinkaAPIKit.Map) where T : Swift.RawRepresentable
public enum LockState : Swift.UInt8 {
  case lock_STARTUP
  case lock_LOCKING
  case lock_UNLOCKING
  case lock_LOCKED
  case lock_UNLOCKED
  case lock_ERROR
  case lock_STALLED
  case lock_LOCKED_PAC
  case lock_UNLOCKED_PAC
  case lock_POWERUP
  case lock_FAULT_LOCKING
  case lock_FAULT_UNLOCKING
  case lock_UNKNOWN_STATE
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
final public class Rabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: LinkaAPIKit.Rabbit.Error, b: LinkaAPIKit.Rabbit.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension LinkaAPIKit.Rabbit : LinkaAPIKit.Cipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public var modelName: Swift.String {
    get
  }
}
open class HexColorTransform : LinkaAPIKit.TransformType {
  public typealias Object = UIKit.UIColor
  public typealias JSON = Swift.String
  public init(prefixToJSON: Swift.Bool = false, alphaToJSON: Swift.Bool = false)
  open func transformFromJSON(_ value: Any?) -> LinkaAPIKit.HexColorTransform.Object?
  open func transformToJSON(_ value: LinkaAPIKit.HexColorTransform.Object?) -> LinkaAPIKit.HexColorTransform.JSON?
  @objc deinit
}
public protocol PaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum Padding : LinkaAPIKit.PaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5, iso78164, iso10126
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: LinkaAPIKit.Padding, b: LinkaAPIKit.Padding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public func <- <Transform>(left: inout Transform.Object, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType
public func >>> <Transform>(left: Transform.Object, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType
public func <- <Transform>(left: inout Transform.Object?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType
public func >>> <Transform>(left: Transform.Object?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType
public func <- <Transform>(left: inout [Transform.Object], right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType
public func >>> <Transform>(left: [Transform.Object], right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType
public func <- <Transform>(left: inout [Transform.Object]?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType
public func >>> <Transform>(left: [Transform.Object]?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType
public func <- <Transform>(left: inout [Swift.String : Transform.Object], right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType
public func >>> <Transform>(left: [Swift.String : Transform.Object], right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType
public func <- <Transform>(left: inout [Swift.String : Transform.Object]?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType
public func >>> <Transform>(left: [Swift.String : Transform.Object]?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType
public func <- <Transform>(left: inout Transform.Object, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable
public func >>> <Transform>(left: Transform.Object, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable
public func <- <Transform>(left: inout Transform.Object?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable
public func >>> <Transform>(left: Transform.Object?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, Transform.Object>, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, Transform.Object>, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, Transform.Object>?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, Transform.Object>?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, [Transform.Object]>, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, [Transform.Object]>, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable
public func <- <Transform>(left: inout Swift.Dictionary<Swift.String, [Transform.Object]>?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable
public func >>> <Transform>(left: Swift.Dictionary<Swift.String, [Transform.Object]>?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable
public func <- <Transform>(left: inout Swift.Array<Transform.Object>, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable
public func >>> <Transform>(left: Swift.Array<Transform.Object>, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable
public func <- <Transform>(left: inout Swift.Array<Transform.Object>?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable
public func >>> <Transform>(left: Swift.Array<Transform.Object>?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable
public func <- <Transform>(left: inout [[Transform.Object]], right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType
public func >>> <Transform>(left: [[Transform.Object]], right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType
public func <- <Transform>(left: inout [[Transform.Object]]?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType
public func >>> <Transform>(left: [[Transform.Object]]?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType
public func <- <Transform>(left: inout Swift.Set<Transform.Object>, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable, Transform.Object : Swift.Hashable
public func >>> <Transform>(left: Swift.Set<Transform.Object>, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable, Transform.Object : Swift.Hashable
public func <- <Transform>(left: inout Swift.Set<Transform.Object>?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable, Transform.Object : Swift.Hashable
public func >>> <Transform>(left: Swift.Set<Transform.Object>?, right: (LinkaAPIKit.Map, Transform)) where Transform : LinkaAPIKit.TransformType, Transform.Object : LinkaAPIKit.BaseMappable, Transform.Object : Swift.Hashable
open class EnumTransform<T> : LinkaAPIKit.TransformType where T : Swift.RawRepresentable {
  public typealias Object = T
  public typealias JSON = T.RawValue
  public init()
  open func transformFromJSON(_ value: Any?) -> T?
  open func transformToJSON(_ value: T?) -> T.RawValue?
  @objc deinit
}
open class NSDecimalNumberTransform : LinkaAPIKit.TransformType {
  public typealias Object = Foundation.NSDecimalNumber
  public typealias JSON = Swift.String
  public init()
  open func transformFromJSON(_ value: Any?) -> Foundation.NSDecimalNumber?
  open func transformToJSON(_ value: Foundation.NSDecimalNumber?) -> Swift.String?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class Helpers : ObjectiveC.NSObject {
  public enum LogLevel : Swift.UInt8 {
    case OFF
    case DEBUG
    case SAVE_TO_STRING
    case DEBUG_AND_SAVE_TO_STRING
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public class func setLogLevel(_ ll: LinkaAPIKit.Helpers.LogLevel)
  public class func getDebugString() -> Swift.String
  public class func clearDebugString()
  @objc override dynamic public init()
  @objc deinit
}
public enum Bit : Swift.Int {
  case zero
  case one
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension LinkaAPIKit.Bit {
  @inlinable internal func inverted() -> LinkaAPIKit.Bit {
    self == .zero ? .one : .zero
  }
}
public typealias COMPLETION = ((_ responseObject: Any?, _ error: Any?) -> Swift.Void)
@objc @_inheritsConvenienceInitializers @objcMembers public class LinkaAPIService : ObjectiveC.NSObject {
  public class func getAPIProtocol() -> LinkaAPIKit.LinkaAPIProtocol!
  public class func setAPIProtocol(_protocol: LinkaAPIKit.LinkaAPIProtocol)
  @objc override dynamic public init()
  @objc deinit
}
public struct PCBC : LinkaAPIKit.BlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: LinkaAPIKit.PCBC.Error, b: LinkaAPIKit.PCBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: LinkaAPIKit.BlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping LinkaAPIKit.CipherOperationOnBlock, encryptionOperation: @escaping LinkaAPIKit.CipherOperationOnBlock) throws -> LinkaAPIKit.CipherModeWorker
}
public protocol AEAD {
  static var kLen: Swift.Int { get }
  static var ivRange: Swift.Range<Swift.Int> { get }
}
public protocol _UInt8Type {
}
extension Swift.UInt8 : LinkaAPIKit._UInt8Type {
}
extension Swift.UInt8 {
  public func bits() -> [LinkaAPIKit.Bit]
  public func bits() -> Swift.String
}
extension Swift.Collection where Self.Element == Swift.UInt8, Self.Index == Swift.Int {
  @inlinable internal func toUInt32Array() -> Swift.Array<Swift.UInt32> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 4)
    return Array<UInt32>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 4) {
        let val = UInt32(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
  @inlinable internal func toUInt64Array() -> Swift.Array<Swift.UInt64> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 8)
    return Array<UInt64>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 8) {
        let val = UInt64(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
}
@usableFromInline
internal func strideCount(from: Swift.Int, to: Swift.Int, by: Swift.Int) -> Swift.Int
extension LinkaAPIKit.HMAC {
  convenience public init(key: Swift.String, variant: LinkaAPIKit.HMAC.Variant = .md5) throws
}
extension LinkaAPIKit.OFB.Error : Swift.Equatable {}
extension LinkaAPIKit.OFB.Error : Swift.Hashable {}
extension LinkaAPIKit.GCM.Mode : Swift.Equatable {}
extension LinkaAPIKit.GCM.Mode : Swift.Hashable {}
extension LinkaAPIKit.GCM.Error : Swift.Equatable {}
extension LinkaAPIKit.GCM.Error : Swift.Hashable {}
extension LinkaAPIKit.HKDF.Error : Swift.Equatable {}
extension LinkaAPIKit.HKDF.Error : Swift.Hashable {}
extension LinkaAPIKit.PairingUpState : Swift.Equatable {}
extension LinkaAPIKit.PairingUpState : Swift.Hashable {}
extension LinkaAPIKit.PairingUpState : Swift.RawRepresentable {}
extension LinkaAPIKit.CCM : LinkaAPIKit.BlockMode {}
extension LinkaAPIKit.CCM.Error : Swift.Equatable {}
extension LinkaAPIKit.CCM.Error : Swift.Hashable {}
extension LinkaAPIKit.PKCS5.PBKDF1.Error : Swift.Equatable {}
extension LinkaAPIKit.PKCS5.PBKDF1.Error : Swift.Hashable {}
extension LinkaAPIKit.PKCS5.PBKDF1.Variant : Swift.Equatable {}
extension LinkaAPIKit.PKCS5.PBKDF1.Variant : Swift.Hashable {}
extension LinkaAPIKit.HMAC.Error : Swift.Equatable {}
extension LinkaAPIKit.HMAC.Error : Swift.Hashable {}
extension LinkaAPIKit.HMAC.Variant : Swift.Equatable {}
extension LinkaAPIKit.HMAC.Variant : Swift.Hashable {}
extension LinkaAPIKit.AES.Error : Swift.Equatable {}
extension LinkaAPIKit.AES.Error : Swift.Hashable {}
extension LinkaAPIKit.AES.Variant : Swift.Equatable {}
extension LinkaAPIKit.AES.Variant : Swift.Hashable {}
extension LinkaAPIKit.AES.Variant : Swift.RawRepresentable {}
extension LinkaAPIKit.CTR : LinkaAPIKit.BlockMode {}
extension LinkaAPIKit.CTR.Error : Swift.Equatable {}
extension LinkaAPIKit.CTR.Error : Swift.Hashable {}
extension LinkaAPIKit.PKCS5.PBKDF2.Error : Swift.Equatable {}
extension LinkaAPIKit.PKCS5.PBKDF2.Error : Swift.Hashable {}
extension LinkaAPIKit.CFB.Error : Swift.Equatable {}
extension LinkaAPIKit.CFB.Error : Swift.Hashable {}
extension LinkaAPIKit.CFB.SegmentSize : Swift.Equatable {}
extension LinkaAPIKit.CFB.SegmentSize : Swift.Hashable {}
extension LinkaAPIKit.CFB.SegmentSize : Swift.RawRepresentable {}
extension LinkaAPIKit.ChaCha20.Error : Swift.Equatable {}
extension LinkaAPIKit.ChaCha20.Error : Swift.Hashable {}
extension LinkaAPIKit.AtCommand : Swift.Equatable {}
extension LinkaAPIKit.AtCommand : Swift.Hashable {}
extension LinkaAPIKit.AtCommand : Swift.RawRepresentable {}
extension LinkaAPIKit.Poly1305.Error : Swift.Equatable {}
extension LinkaAPIKit.Poly1305.Error : Swift.Hashable {}
extension LinkaAPIKit.SHA2.Variant : Swift.Equatable {}
extension LinkaAPIKit.SHA2.Variant : Swift.Hashable {}
extension LinkaAPIKit.SHA2.Variant : Swift.Sendable {}
extension LinkaAPIKit.MappingType : Swift.Equatable {}
extension LinkaAPIKit.MappingType : Swift.Hashable {}
extension LinkaAPIKit.PRIV_LEVEL : Swift.Equatable {}
extension LinkaAPIKit.PRIV_LEVEL : Swift.Hashable {}
extension LinkaAPIKit.PRIV_LEVEL : Swift.RawRepresentable {}
extension LinkaAPIKit.LinkaBLECommunicationManager.AlarmSensitivity : Swift.Equatable {}
extension LinkaAPIKit.LinkaBLECommunicationManager.AlarmSensitivity : Swift.Hashable {}
extension LinkaAPIKit.UserCommand : Swift.Equatable {}
extension LinkaAPIKit.UserCommand : Swift.Hashable {}
extension LinkaAPIKit.UserCommand : Swift.RawRepresentable {}
extension LinkaAPIKit.AudioSetting : Swift.Equatable {}
extension LinkaAPIKit.AudioSetting : Swift.Hashable {}
extension LinkaAPIKit.AudioSetting : Swift.RawRepresentable {}
extension LinkaAPIKit.ErrorOther : Swift.Equatable {}
extension LinkaAPIKit.ErrorOther : Swift.Hashable {}
extension LinkaAPIKit.ErrorOther : Swift.RawRepresentable {}
extension LinkaAPIKit.ErrorKeyfobAssign : Swift.Equatable {}
extension LinkaAPIKit.ErrorKeyfobAssign : Swift.Hashable {}
extension LinkaAPIKit.ErrorKeyfobAssign : Swift.RawRepresentable {}
extension LinkaAPIKit.CipherError : Swift.Equatable {}
extension LinkaAPIKit.CipherError : Swift.Hashable {}
extension LinkaAPIKit.Blowfish.Error : Swift.Equatable {}
extension LinkaAPIKit.Blowfish.Error : Swift.Hashable {}
extension LinkaAPIKit.CMAC.Error : Swift.Equatable {}
extension LinkaAPIKit.CMAC.Error : Swift.Hashable {}
extension LinkaAPIKit.SHA3.Variant : Swift.Equatable {}
extension LinkaAPIKit.SHA3.Variant : Swift.Hashable {}
extension LinkaAPIKit.LeoMode : Swift.Equatable {}
extension LinkaAPIKit.LeoMode : Swift.Hashable {}
extension LinkaAPIKit.LeoMode : Swift.RawRepresentable {}
extension LinkaAPIKit.OCB.Mode : Swift.Equatable {}
extension LinkaAPIKit.OCB.Mode : Swift.Hashable {}
extension LinkaAPIKit.OCB.Error : Swift.Equatable {}
extension LinkaAPIKit.OCB.Error : Swift.Hashable {}
extension LinkaAPIKit.CBC.Error : Swift.Equatable {}
extension LinkaAPIKit.CBC.Error : Swift.Hashable {}
extension LinkaAPIKit.LockContextPacket.CellState : Swift.Equatable {}
extension LinkaAPIKit.LockContextPacket.CellState : Swift.Hashable {}
extension LinkaAPIKit.LockContextPacket.CellState : Swift.RawRepresentable {}
extension LinkaAPIKit.AuthState : Swift.Equatable {}
extension LinkaAPIKit.AuthState : Swift.Hashable {}
extension LinkaAPIKit.AuthState : Swift.RawRepresentable {}
extension LinkaAPIKit.LockState : Swift.Equatable {}
extension LinkaAPIKit.LockState : Swift.Hashable {}
extension LinkaAPIKit.LockState : Swift.RawRepresentable {}
extension LinkaAPIKit.Rabbit.Error : Swift.Equatable {}
extension LinkaAPIKit.Rabbit.Error : Swift.Hashable {}
extension LinkaAPIKit.Padding : Swift.Equatable {}
extension LinkaAPIKit.Padding : Swift.Hashable {}
extension LinkaAPIKit.Helpers.LogLevel : Swift.Equatable {}
extension LinkaAPIKit.Helpers.LogLevel : Swift.Hashable {}
extension LinkaAPIKit.Helpers.LogLevel : Swift.RawRepresentable {}
extension LinkaAPIKit.Bit : Swift.Equatable {}
extension LinkaAPIKit.Bit : Swift.Hashable {}
extension LinkaAPIKit.Bit : Swift.RawRepresentable {}
extension LinkaAPIKit.PCBC.Error : Swift.Equatable {}
extension LinkaAPIKit.PCBC.Error : Swift.Hashable {}
